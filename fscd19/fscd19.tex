
\documentclass[a4paper,USenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage{bm} % bold math
% \usepackage{dsfont} % black-board bold numbers, package doublestroke
% LACKS: \mathds{0}

% Disallowed packages:
% - enumitem
% - paralist
% - natbib
% - wrapfig

% Disallowed:
% - conditional inclusion of content
% - splitting over several files

% LIPICS enumerations
% - itemize
% - enumerate 1.
% - alphaenumerate (a)
% - romanenumerate (i)
% - bracketenumerate (1)

% LIPICS environments
% - lstlisting
% - theorem
% - lemma
% - corollary
% - proposition
% - exercise
% - definition
% - example
% - note and note*
% - remark and remark*
% - claim and claim*
% - proof and claimproof

% Features
% - env: claim and claimproof inside proof

% References to lemmata
% - \cref and \autoref (includes name, like Corollary 3)


%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\input{macros}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Normalization by Evaluation for Call-by-Push-Value and Focused Lambda-Calculus}

\titlerunning{NbE for CBPV and Focusing}%optional, please use if title is longer than one line

\author{Andreas Abel}
  {Department of Computer Science and Engineering,
    Chalmers and Gothenburg University,
    Sweden \and
    \url{www.cse.chalmers.se/~abela}
  }
  {andreas.abel@gu.se}
  {https://orcid.org/0000-0003-0420-4492}
  {VR Grant 2014-04864 \emph{Termination
      Certificates for Dependently-Typed Programs and Proofs via
      Refinement Types}
  }
% TODO mandatory, please use full name;
% only 1 author per \author macro;
% first two parameters are mandatory, other parameters can be empty.
% Please provide at least the name of the affiliation and the country.
% The full address is optional


\author{Frederik Folkmar Ramcke}
  {Department of Computer Science and Engineering,
    Chalmers and Gothenburg University,
    Sweden
  }
  {}%email
  {}%orcid
  {}%funding


\author{Christian Sattler}
  {Department of Computer Science and Engineering,
    Chalmers and Gothenburg University,
    Sweden
  }
  {}%email
  {}%orcid
  {}%funding

\authorrunning{A. Abel and F. F. Ramcke and C. Sattler}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andreas Abel and Frederik F. Ramcke and Christian Sattler}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{General and reference~General literature}
\ccsdesc[100]{General and reference}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{Evaluation, Intuitionistc Propositional Logic,
  Lambda-Calculus, Monad, Normalization,
  Polarized Logic, Semantics}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{ The presentation of this NbE proof and its
Agda formalization benefited greatly from discussions with Christian
Sattler.}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{Jakob Rehof and XXX}
\EventNoEds{2}
\EventLongTitle{Formal Structures for Computation and Deduction}
\EventShortTitle{FSCD 2019}
\EventAcronym{FSCD}
\EventYear{2019}
\EventDate{June 24--30, 2019}
\EventLocation{Dortmund, Germany}
\EventLogo{}
\SeriesVolume{}
\ArticleNo{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
  We extend normalization by evaluation (NbE) to call-by-push-value
  (CBPV) and focused intutitionistic propositional logic.
  The developments have been partially formalized in Agda.
\end{abstract}


\section{Introduction}
\label{sec:intro}

Weak coproducts.
Weak sheaf (non-unique pasting).

Contributions:
\begin{enumerate}
\item Abstract cover monad.
\item NbE for CBPV and polarized lambda-calculus.
\end{enumerate}

CBPV differs from PolLambda in that hypotheses can be arbitrary
positive formulas in CBPV, but only positive atoms or negative
formulas in PolLambda.  This means that in CBPV, there is more choice
on when and how to decompose a hypothesis into ones of smaller
positive type, whereas in PolLambda there is no freedom: mandatory
maximal splitting is dictated by the left inversion phase.

Normal forms of CBPV thus retain individual shallow pattern matching
constructs, while PolLambda has only deep, maximal pattern matching.

Agda formalization:
Sized types, nested data types.

\nocite{bergerSchwichtenberg:lics91}

\nocite{jungTiuryn:tlca93}

\nocite{altenkirchHofmannStreicher:ctcs95}

\nocite{abel:habil}

\nocite{danvy:popl96}

\nocite{fioreSimpson:tlca99}

\nocite{altenkirchDybjerHofmannScott:lics01}

\nocite{balatDiCosmoFiore:popl04}

\nocite{altenkirchUustalu:flops04}

\nocite{barral:PhD}

\nocite{scherer:popl17}


\section{Normalization by Evaluation for the Simply-Typed Lambda
  Calculus with Sums}
\label{sec:lambda}

In this section, we review the normalization by evaluation (NbE)
argument for the simply-typed lambda calculus (STLC) with weak sums, setting
the stage for the later sections.
%
We work in a constructive type-theoretic meta-language, with the basic judgement
$t : T$ meaning that object $t$ is an inhabitant of type $T$.
However, to avoid confusion with object-level types such as the simple
types of lambda calculus, we will refer to meta-level types as
\emph{sets}.  Consequently, the colon $:$
takes the role of elementhood $\in$ in set-theory, and we are free to
reuse the symbol $\in$ for other purposes.

\subsection{Contexts and indices}

We adapt a categorical aka de Bruijn style for the abstract syntax of
terms, which we conceive as intrinsically well-typed.  In de Bruijn
style, a context $\Gamma$ is just a snoc list of simple types $A$,
meaning we write context extension as $\cext \Gamma A$, and the empty
context as $\cempty$.  Membership \fbox{$A \in \Gamma$} and sublist
relations \fbox{$\Gamma \sublist \Delta$} are given inductively by the
following rules:
\begin{gather*}
  \nru{\tzero}{}{A \in \cext \Gamma A}
\qquad
  \nru{\tsuc}{A \in \Gamma}{A \in \cext \Gamma B}
\qquad
  \nru{\tdone}{}{\cempty \sublist \cempty}
\qquad
  \nru{\tlift}
    {\Gamma \sublist \Delta}
    {\cext \Gamma A \sublist \cext \Delta A}
\qquad
  \nru{\tweak}
    {\Gamma \sublist \Delta}
    {\Gamma \sublist \cext \Delta A}
\end{gather*}
We consider the rules as introductions of the indexed types
$\_{\in}\_$ and $\_{\sublist}\_$ and the rule names as constructors.
For instance, $\suc \tzero : A \in \cext {\cext \Gamma A} B$ for any
$\Gamma$, $A$, and $B$; and if we read $\tsuc^n\,\tzero$ as unary
number $n$, then $x : A \in \Gamma$ is exactly the (de Bruijn) index
of $A$ in $\Gamma$.

We can define
\fbox{$\tid : \Gamma \sublist \Gamma$} and \fbox{$\_{\rcomp}\_ : \Gamma
\sublist \Delta \to \Delta \sublist \Phi \to \Gamma \sublist \Phi$}
by recursion, meaning that the (proof-relevant)
sublist relation is reflexive and transitive.
% The sublist relation is reflexive and transitive, the witnesses
% \fbox{$\tid : \Gamma \sublist \Gamma$} and \fbox{$\_{\rcomp}\_ : \Gamma
% \sublist \Delta \to \Delta \sublist \Phi \to \Gamma \sublist \Phi$}
% have easy recursive definitions.
Thus, lists $\Gamma$ form a category
$\Cxt$ with morphisms $\tau : \Gamma \sublist \Delta$, and the category laws
hold propositionally, e.g., we have $\id \rcomp \tau \equiv \tau$ in
propositional equality for all morphisms $\tau$.

The category $\Cxt$ allows us to consider $A{\in}\_$ as a presheaf over
$\Cxt\op$ for any $A$, witnessed by \fbox{$\treindex : \Gamma \sublist
  \Delta \to A \in \Gamma \to A \in \Delta$}, which is the morphism
part of functor from $\Cxt$ to $\Set$, mapping object $\Gamma$ to the
set $A \in \Gamma$ of the indices of $A$ in $\Gamma$.
The associated naturality laws \fbox{$\treindex\,\tid\,x \equiv x$}
and \fbox{$\treindex\,\tau_2\,(\treindex\,\tau_1\,x) \equiv
\treindex\,(\tau_1 \rcomp \tau_2)\,x$} hold propositionally.

\subsection{STLC and its normal forms}

Simple types shall be distinguished into positive types $P$ and
negative types $N$, depending on their root type former.  Function
($\To$) and product types ($\times$ and $\tyone$) are negative,
while base types ($\tybase$) and sum types ($+$ and $\tyzero$) are positive.
\[
\begin{array}{lrl@{\qquad}l}
  A,B,C & ::= & P \mid N & \mbox{simple types} \\
  P     & ::= & \tyzero \mid A + B \mid \tybase & \mbox{positive types} \\
  N     & ::= & \tyone \mid A \times B \mid A \To B
  % P     & ::= & a \mid A + B \mid \tyzero & \mbox{positive types} \\
  % N     & ::= & A \To B \mid A \times B \mid \tyone
    & \mbox{negative types} \\
\end{array}
\]
% Simple types shall be given by the grammar
% % \fbox{$S,T ::= P \mid S \To T \mid S \times T \mid \tyone \mid S + T
% %   \mid \tyzero$}.
% \fbox{$A,B,C ::= a \mid A \To B \mid A \times B \mid \tyone \mid A + B
%   \mid \tyzero$}.
% Herein, $a$ ranges over atomic types aka base types.
Intrinsically well-typed lambda-terms, in abstract syntax,
are just inhabitants $t$ of the type \fbox{$A \from \Gamma$},
inductively defined by the following rules.
\begin{gather*}
  \nru{\tvar}{A \in \Gamma}{A \from \Gamma}
\qquad
  \nru{\tabs}{B \from \cext \Gamma A}{A \To B \from \Gamma}
\qquad
  \nru{\tapp}
    {A \To B \from \Gamma \qquad A \from \Gamma}
    {B \from \Gamma}
\\[2ex]
  \nru{\tunit}{}{\tyone \from \Gamma}
\qquad
  \nru{\tpair}
    {A_1 \from \Gamma \qquad A_2 \from \Gamma}
    {A_1 \times A_2 \from \Gamma}
\qquad
  \nru{\tprj_i}
    {A_1 \times A_2 \from \Gamma}
    {A_i \from \Gamma}
\\[2ex]
  \nru{\tinj_i}
    {A_i \from \Gamma}
    {A_1 + A_2 \from \Gamma}
\qquad
  \nru{\tcase}
    {A_1 + A_2 \from \Gamma
      \qquad C \from \cext \Gamma A_1
      \qquad C \from \cext \Gamma A_2
    }{C \from \Gamma}
\qquad
  \nru{\tabort}
    {\tyzero \from \Gamma}
    {C \from \Gamma}
\end{gather*}
The skilled eye of the reader will immediately recognize the proof
rules of intuitionistic propositional logic (IPL) under the
Curry-Howard isomorphism.  A term such as
\(
  \tabs\,(\tabs\,(\tpair\,
    (\tvar\,(\tsuc\,\tzero))\,
    (\tabs\,(\tapp\,(\tvar\,(\tsuc\,\tzero))\,(\tvar\,\tzero)))))
\)
could in concrete syntax be rendered as
\(
  \lambda x.\,\lambda y.\,(x,\,\lambda z.\,y\,z)
  .
\)
We leave the exact connection to a printable
syntax of the STLC to imagination of the reader,
as we shall not be concerned with considering
concrete terms in this article.

Terms of type $A$ form a presheaf
$A{\from}\_$ as witnessed by the standard weakening operation%
\footnote{Here, $\tren$ is short for \emph{renaming}, but in a nameless
calculus we should better speak of \emph{reindexing}, which could, a
bit clumsily, also abbreviated to $\tren$.}
\fbox{$\tren : \Gamma \sublist \Delta \to A \from \Gamma \to A \from \Delta$}
defined by recursion over $t : A \from \Gamma$,
and naturality laws for $\tren$ analogously to $\treindex$.

Normal forms%
\footnote{%
There is also a stronger
notion of normal form, requiring that two \emph{extensionally equal}
lambda-terms, \ie, those that denote the
same set-theoretical function, have the same normal form
\cite{mitchell:foundations,altenkirchDybjerHofmannScott:lics01,scherer:popl17}.
Such normal forms do not have a simple inductive definition, and we
shall not consider them in this article.
}
are logically characterized as those fulfilling the
\emph{subformula} property \cite{prawitz:natded,matthes:shortproofs}.
Normal forms \fbox{$t : \tNf A\, \Gamma$} are mutually defined with
\emph{neutral} normal forms \fbox{$t : \Ne A \Gamma$}.
In the following inductive definition, we reuse the rule names from the
term constructors.
\begin{gather*}
  \nru{\tvar}{A \in \Gamma}{\Ne A \Gamma}
\qquad
  \nru{\tabs}{\NfC B {\cext \Gamma A}}{\NfP {A \To B} \Gamma}
\qquad
  \nru{\tapp}
    {\NeP {A \To B} \Gamma \qquad \Nf A \Gamma}
    {\Ne B \Gamma}
\qquad
  \nru{\tne}{\Ne \tybase \Gamma}{\Nf \tybase \Gamma}
\\[2ex]
  \nru{\tunit}{}{\Nf \tyone \Gamma}
\qquad
  \nru{\tpair}
    {\Nf {A_1} \Gamma \qquad \Nf {A_2} \Gamma}
    {\NfP {A_1 \times A_2} \Gamma}
\qquad
  \nru{\tprj_i}
    {\NeP {A_1 \times A_2} \Gamma}
    {\Ne {A_i} \Gamma}
\\[2ex]
  \nru{\tinj_i}
    {\Nf {A_i} \Gamma}
    {\NfP {A_1 + A_2} \Gamma}
\quad
  \nru{\tcase}
    {\NeP {A_1 + A_2} \Gamma
      \quad \NfC P {\cext \Gamma A_1}
      \quad \NfC P {\cext \Gamma A_2}
    }{\Nf P \Gamma}
\quad
  \nru{\tabort}
    {\Ne \tyzero \Gamma}
    {\Nf P \Gamma}
\end{gather*}
These rules only allow the elimination of neutrals; guarantees
the subformula property and prevents any kind of computational
($\beta$) redex.
The new rule $\tne$ embeds $\tNe$ into $\tNf$,
but only at base types $\tybase$.
Further, case distintion via $\tcase$ and $\tabort$
is restricted to positive types $P$.
As a consequence, our normal forms are
\emph{$\eta$-long}, meaning that any normal inhabitant of a negative
type is a respective introduction ($\tabs$, $\tunit$, or $\tpair$).
This justifies the attribute \emph{negative} for these types:
the construction of their inhabitants proceeds mechanically, without
any choices.  In contrast, to construct an inhabitant of a
\emph{positive} type choice is required: whether case distinction is
required, and which introduction to pick in the end ($\tinj_1$ or $\tinj_2$).

Needless to say, $\tNe\,A$ and
$\tNf\,A$ are presheaves, \ie, support reindexing with $\tren$ just as terms do.
From a normal form we can extract the term via an overloaded function
\fbox{$\tm\_ : \Nf A \Gamma \to A \from \Gamma$} and
\fbox{$\tm\_ : \Ne A \Gamma \to A \from \Gamma$}
that discards constructor $\tne$ but keeps all other constructors.
This erasure function naturally commutes with reindexing, making it a
natural transformation between the presheaves $\tNf\,A$ ($\tNe\,A$,
resp.) and $A{\from}\_$.  We shall simply write, for instance,
\fbox{$\tNf\,A \todot A{\from}\_$} for such presheaf morphisms.
(The point on the arrow is mnemoic for \emph{pointwise}.)

\emph{Proof normalization} is concerned with finding a normal form
$u : \Nf A \Gamma$ for each derivation $t : A \from \Gamma$.  However,
\emph{term normalization} additionally requires that $\tm u \cong t$
with respect to a equational theory $\cong$ on terms.

\subsection{Proof normalization}

For didactical purposes, let us first focus on the simpler task of
constructing a normalization function
\fbox{$\tnorm : A \from \Gamma \to \Nf A \Gamma$}
that does not guarantee any relation between its input term $t$ and
output normal form $u$.
% \emph{Normalization by evaluation} (NbE) decomposes normalization as
% \fbox{\(
%   \norm[\Gamma] A (t : A \from \Gamma)
%   = \down[\Gamma] A \dent t {\idenv\Gamma}
% \)}
% which is
% \emph{evaluation}
% \nofbox{$\dent \_ \_ : (t : A \from \Gamma) \to \Den \Gamma \Delta \to
%   \Den A \Delta$}
% in the identity environment \nofbox{$\idenv\Gamma : \Den \Gamma \Gamma$}
% followed by
% \emph{reification}
% \nofbox{$\downG A : \Den A \Gamma \to \Nf A \Gamma$}.
\emph{Normalization by evaluation} (NbE) decomposes normalization as
\fbox{\(
%  \norm[\Gamma] A (t : A \from \Gamma)
  \tnorm\, (t : A \from \Gamma)
  = \down A \dent t {\idenv\Gamma}
\)}
which is
\emph{evaluation}
\nofbox{$\dent \_ \_ : (t : A \from \Gamma) \to \den \Gamma \todot
  \den A$}
in the identity environment \nofbox{$\idenv\Gamma : \den \Gamma \Gamma$}
followed by
\emph{reification}
\nofbox{$\down A : \den A \todot \tNf A$}.
The role of evaluation is to produce from a term the corresponding
semantic (\ie, meta-theoretic) function, which is finally reified to a normal form.
Since we are evaluating open terms $t$, we need to supply an environment
$\idenv\Gamma$ which will map the free indices of $t$ to corresponding
\emph{unknowns}.  To accomodate unknowns in the semantics, types $A$
are mapped to presheaves $\den A$ (rather than just sets), and in
particular each base type $\tybase$ is mapped to the presheaf
$\tNe\,\tybase$ with the intention that the neutrals take the role of
the unknowns.  The mapping $\up A : \tNe\,A \todot \den A$ from
neutrals to unknowns is called \emph{reflection}, and defined mutually
with reification by induction on type $A$.

At this point, let us fix some notation for sets to prepare for some
constructions of presheaves.  Let $\bone$ denote the unit set and
$\ttempty$ its unique inhabitant, $\bzero$ the empty set and
$\tmagic : \bzero \to T$ the \emph{ex falsum quod libet} elimination
into any set $T$.  Given sets $S_1$ and $S_2$, their Cartesian product
is written $S_1 \btimes S_2$ with projections $\pi_i : S_1 \btimes S_2
\to S_i$, and their disjoint sum $S_1 \bplus S_2$ with injections
$\iota_i : S_i \to S_1 \bplus S_2$ and elimination $[f_1,f_2] : S_1 \bplus
S_2 \to T$ for arbitrary $f_i : S_i \to T$.

Presheafs (co)products $\hat0$, $\hat1$, $\hatplus$, and $\hattimes$ are
constructed pointwise, \eg, $\hat0\,\Gamma = \bzero$, and given two
presheaves $\A$ and $\B$,
$(\A \hatplus \B)\,\Gamma = \A\,\Gamma \bplus \B\,\Gamma$.  For the
exponential of presheaves, however, we need the \emph{Kripke function
  space}
$(\A \hatto \B)\,\Gamma = \forall \Delta.\, \Gamma \sublist \Delta
\to \A\,\Delta \to \B\,\Delta$.

We will interpret simple types $A$ as corresponding presheaves
$\den A$.  Let us start with the negative types, defining
reflection $\up A : \tNe\, A \todot \den A$
and reification $\down A : \den A \todot \tNf A$ along the way.
\begin{gather*}
\begin{array}{lcl}
  \den   \tyone          & = & \hatone \\
  \upG   \tyone \; u     & = & \ttempty \\
  \downG \tyone \ttempty & = & \tunit \\
\end{array}
\qquad\qquad\qquad
\begin{array}{lcl}
  \den   {A \times B}       & = & \den A \hattimes \den B \\
  \upG   {A \times B} \; u  & = & (\upG A (\prj1 u),\;\upG B (\prj2 u)) \\
  \downG {A \times B} (a,b) & = & \tpair\,(\downG A a)\,(\downG B b) \\
\end{array}
\\[2ex]
\begin{array}{lcl}
  \den {A \To B}    & = & \den A \hatto \den B \\
  \upG   {A \To B}    \; u \; (\tau : \Gamma \sublist \Delta) \; (a : \den A \Delta)
     & = & \up[\Delta] B (\tapp\;(\tren\,\tau\, u)\;(\down[\Delta] A a)) \\
  \downG {A \To B}    f        & = & \tabs\,(\down[\cext \Gamma A] B
    (f\;\twk^A_\Gamma\;\tfresh^A_\Gamma))
\end{array}
\end{gather*}
% We will interpret simple types $A$ as corresponding presheaves
% $\den A$.  Let us start with the negative types:
% \[
% \begin{array}{lcl}
%   \den \tyone       & = & \hatone \\
%   \den {A \times B} & = & \den A \hattimes \den B \\
%   \den {A \To B}    & = & \den A \hatto \den B \\
% \end{array}
% \]
% Reflection $\up A : \tNe\, A \todot \den A$
% and reification $\down A : \den A \todot \tNf A$
% are defined mutually by induction on type $A$.
% \begin{gather*}
% \begin{array}{lcl@{\qquad}lcl}
%   \upG   \tyone       u        & = & \ttempty &
%   \downG \tyone       \ttempty & = & \tunit \\
%   \upG   {A \times B} u        & = & (\upG A (\prj1 u),\;\upG B (\prj2 u)) &
%   \downG {A \times B} (a,b)    & = & \tpair\,(\downG A a)\,(\downG B b) \\
% \end{array}
% \\
% \begin{array}{lcl@{\qquad}lcl}
%   \upG   {A \To B}    u \; (\tau : \Gamma \sublist \Delta) \; (a : \den A \Delta)
%      & = & \up[\Delta] B (\tapp\;(\tren\;\tau\; u)\;(\down[\Delta] A a)) \\
%   \downG {A \To B}    f        & = & \tabs\,(\down[\cext \Gamma A] B
%     (f\,(\twk^A)\,(\tfresh^A_\Gamma)))
% \end{array}
% \end{gather*}
In the equation for $\down{A \To B}$,
the renaming $\twk : \Gamma \sublist \cext \Gamma A$,
defined by $\twk = \tweak\,\tid$, makes room
for a new variable of type $A$, which is reflected into $\den A$ by
\[
\begin{array}{lcl@{\qquad}lcl}
  \tfresh : \den A (\cext \Gamma A) \\
  \tfresh = \up[\cext \Gamma A] A (\tvar\;\tzero)
  . \\
\end{array}
\]
The ability to introduce fresh variables into a context, and to use
semantic objects such as $f : \den{A \To B}\Gamma$ in a such extended
context, is the reason for utilizing presheaves instead of just sets.

Note also that in the equation for $\up{A \To B}$,
the neutral $u : \Ne A \Gamma$ is
transported into $\Ne A \Gamma$ via reindexing with
$\tau : \Gamma \sublist \Delta$, in order to be applicable to the normal form
$\down[\Delta]A a$
reified from the semantic value $a$.

A direct extension of our presheaf semantics to positive types cannot
work.  For instance, with $\den \tyzero = \hat0$, simply
$\up[\tyzero] \tyzero (\tvar\,\tzero) : \bzero$ would give us an
inhabitant of the empty set, which means that reflection at the empty
type would not be definable.  Similarily, the setting
$\den{A + B} = \den A \hatplus \den B$ is refuted by
% $\up[\tyone + \tyone]^{\tyone + \tyone} (\tvar\,\tzero) : \bone \bplus \bone$
$\up[A + B]{A + B} (\tvar\,\tzero) : \den A (A+B) \bplus \den B (A+B)$
which would require us to make a decision of whether $A$ holds or $B$ holds
while only be given a hypothesis of type $A + B$.
Not even the usual interpretation of base types $\den o = \tNe\,o$
works in the presence of sums, as we would not be able to interpret
the term
$\tabs\,(\tcase\,(\tvar\,\tzero)\,(\tvar\,\tzero)\,(\tvar\,\tzero)) :
(o+o) \To o$ in our semantics, as $\Ne o (o+o)$ is empty.
What is needed are case distinctions on neutrals in the semantics,
allowing us the elimination of positive hypotheses before producing a
semantic value,
and we shall capture this capability in a monad $\C$.

To recapitulate, a monad $\C$ on presheaves is first an endofunctor,
i.e., it maps any presheaf $\A$ to the presheaf $\C\,\A$ and any
presheaf morphism $f : \A \todot \B$ to the morphism
$\tmap[\C]f: \C\,A \todot \C\,\B$ satisfying the functor laws for
identity and composition.  Then, there are natural transformations
$\treturn[\C] : \A \todot \C\,\A$ (unit) and
$\tjoin[\C] : \C\,(\C\,A) \todot \C\,\A$ (concatenation) satisfying
the monad laws.

We are looking for a monad $\C$ that
offers us these services:
% \begin{enumerate}
% \item Elimination of absurd neutrals
% $\tabort^\C : \tNe\, \tyzero \todot \C\,\A$.
% \item Case distinction on neutrals of sum type
% $\tcase^\C_\Gamma : \Ne {(A + B)} \Gamma
%   \to \C\,\A\,(\cext \Gamma A)
%   \to \C\,\A\,(\cext \Gamma B)
%   \to \C\,\A\,\Gamma$.
% \item Run the monad to produce a normal form
% $\trun^\C : \C\,(\Nf A) \todot \Nf A$.
% \end{enumerate}
\[
\begin{array}{lcl@{\quad}l}
\tabort^\C & : & \tNe\, \tyzero \todot \C\,\A
  & \mbox{case on absurd neutral} \\
\tcase^\C_\Gamma & : & \Ne {(A + B)} \Gamma
  \to \C\,\A\,(\cext \Gamma A)
  \to \C\,\A\,(\cext \Gamma B)
  \to \C\,\A\,\Gamma
  & \mbox{case on neutral} \\
\trunNf[\C] & : & \C\,(\tNf A) \todot \tNf A
  & \mbox{run the monad ($\tNf$ only)} \\
\end{array}
\]
Using these services, we can complete our semantics:
%\begin{gather*}
\[
\begin{array}{lcl}
  \den \tybase & = & \C\,(\tNe\,\tybase) \\
  \upG \tybase \; u & = & \treturn[\C]\,u \\
  \downG \tybase \; m & = & \trunNf[\C]\,(\tmap[\C]\tne\;m) \\
\end{array}
\qquad
\begin{array}{lcl}
  \den \tyzero & = & \C\,\hat0 \\
  \upG \tyzero \; u & = & \tabort^\C\,u \\
  \downG \tyzero \; m & = & \trunNf[\C]\,(\tmap[\C]\tmagic\;m) \\
\end{array}
\]
\[
\begin{array}{lcl}
  \den {A+B} & = & \C\,(\den A \hatplus \den B) \\
  \upG {A+B} \; u & = & \tcase^\C\,u
    \,(\treturn[\C]\,(\iota_1\,\tfresh^A_\Gamma))
    \,(\treturn[\C]\,(\iota_2\,\tfresh^B_\Gamma))
    \\
  \downG {A+B} \; m & = & \trunNf[\C]\,
    (\tmap[\C] [\tinj_1 \comp \down A,\; \tinj_2 \comp \down B]\;m) \\
\end{array}
\]
%\end{gather*}

\clearpage

\subsection{Term normalization}

Defining%
\footnote{%
A more accurate presentation of $\tNF$ would be
$\sum_{u : \tNf A\,\Gamma} (\tm u \cong t)$
in order to make absolutely clear that we
want get hold of the witness $u$ of the existential statement;
however, we shall only use constructive
existentials
in this article and thus stick to the notation $\exists$.
We mean \emph{constructive existence} in
  contrast to classical existence and
  \emph{mere existence} from Homotopy Type Theory which
  requires propositional truncation.
}
\fbox{$\NF t = \exists u \of \tNf A\,\Gamma.\; \tm u \cong t$}
% for $t : A \from \Gamma$,
we aim to construct a normalization function
\[
  \tnorm : (t : A \from \Gamma) \to \NF t
\]
that gives us for each term $t$ a $\cong$-equal normal form $u$.

\section{Call-By-Push Value}
\label{sec:cbpv}

\section{Focused Intuitionistic Propositional Logic}
\label{sec:fipl}

\section{Conclusion}
\label{sec:concl}

\bibliography{auto-fscd19}

% \appendix

\end{document}
