
\documentclass[a4paper,USenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage{bm} % bold math
% \usepackage{dsfont} % black-board bold numbers, package doublestroke
% LACKS: \mathds{0}

% Disallowed packages:
% - enumitem
% - paralist
% - natbib
% - wrapfig

% Disallowed:
% - conditional inclusion of content
% - splitting over several files

% LIPICS enumerations
% - itemize
% - enumerate 1.
% - alphaenumerate (a)
% - romanenumerate (i)
% - bracketenumerate (1)

% LIPICS environments
% - lstlisting
% - theorem
% - lemma
% - corollary
% - proposition
% - exercise
% - definition
% - example
% - note and note*
% - remark and remark*
% - claim and claim*
% - proof and claimproof

% Features
% - env: claim and claimproof inside proof

% References to lemmata
% - \cref and \autoref (includes name, like Corollary 3)


%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\input{macros}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Normalization by Evaluation for Call-by-Push-Value and Polarized Lambda-Calculus}

\titlerunning{NbE for CBPV and Focusing}%optional, please use if title is longer than one line

\author{Andreas Abel}
  {Department of Computer Science and Engineering,
    Chalmers and Gothenburg University,
    Sweden \and
    \url{www.cse.chalmers.se/~abela}
  }
  {andreas.abel@gu.se}
  {https://orcid.org/0000-0003-0420-4492}
  {VR Grant 2014-04864 \emph{Termination
      Certificates for Dependently-Typed Programs and Proofs via
      Refinement Types}
  }
% TODO mandatory, please use full name;
% only 1 author per \author macro;
% first two parameters are mandatory, other parameters can be empty.
% Please provide at least the name of the affiliation and the country.
% The full address is optional


% \author{Frederik Folkmar Ramcke}
%   {Department of Computer Science and Engineering,
%     Chalmers and Gothenburg University,
%     Sweden
%   }
%   {}%email
%   {}%orcid
%   {}%funding


\author{Christian Sattler}
  {Department of Computer Science and Engineering,
    Chalmers and Gothenburg University,
    Sweden
  }
  {}%email
  {}%orcid
  {}%funding

\authorrunning{A. Abel %and F. F. Ramcke
and C. Sattler}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andreas Abel %and Frederik F. Ramcke
 and Christian Sattler}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{General and reference~General literature}
\ccsdesc[100]{General and reference}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{Evaluation, Intuitionistic Propositional Logic,
  Lambda-Calculus, Monad, Normalization,
  Polarized Logic, Semantics}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{The first author took inspiration from some
  unpublished notes by Thorsten Altenkirch titled
\emph{Another topological completeness proof for intuitionistic logic}
received by email on 16th March 2000.
Thorsten in turn credits his inspiration to an ALF proof by Thierry
Coquand.}
% \acknowledgements{ The presentation of this NbE proof and its
% Agda formalization benefited greatly from discussions with Christian
% Sattler.}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{Jakob Rehof and XXX}
\EventNoEds{2}
\EventLongTitle{Formal Structures for Computation and Deduction}
\EventShortTitle{FSCD 2019}
\EventAcronym{FSCD}
\EventYear{2019}
\EventDate{June 24--30, 2019}
\EventLocation{Dortmund, Germany}
\EventLogo{}
\SeriesVolume{}
\ArticleNo{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
\input{abstract.txt}
\end{abstract}


\section{Introduction}
\label{sec:intro}

Weak coproducts.
Weak sheaf (non-unique pasting).

Contributions:
\begin{enumerate}
\item Abstract cover monad.
\item NbE for CBPV and polarized lambda-calculus.
\end{enumerate}

CBPV differs from PolLambda in that hypotheses can be arbitrary
positive formulas in CBPV, but only positive atoms or negative
formulas in PolLambda.  This means that in CBPV, there is more choice
on when and how to decompose a hypothesis into ones of smaller
positive type, whereas in PolLambda there is no freedom: mandatory
maximal splitting is dictated by the left inversion phase.

Normal forms of CBPV thus retain individual shallow pattern matching
constructs, while PolLambda has only deep, maximal pattern matching.

Agda formalization:
Sized types, nested data types.

\nocite{bergerSchwichtenberg:lics91}

\nocite{jungTiuryn:tlca93}

\nocite{altenkirchHofmannStreicher:ctcs95}

\nocite{abel:habil}

\nocite{danvy:popl96}

\nocite{fioreSimpson:tlca99}

\nocite{altenkirchDybjerHofmannScott:lics01}

\nocite{balatDiCosmoFiore:popl04}

\nocite{altenkirchUustalu:flops04}

\nocite{barral:PhD}

\nocite{scherer:popl17}


\section{Normalization by Evaluation for the Simply-Typed Lambda
  Calculus with Sums}
\label{sec:lambda}

In this section, we review the normalization by evaluation (NbE)
argument for the simply-typed lambda calculus (STLC) with weak sums, setting
the stage for the later sections.
%
We work in a constructive type-theoretic meta-language, with the basic judgement
$t : T$ meaning that object $t$ is an inhabitant of type $T$.
However, to avoid confusion with object-level types such as the simple
types of lambda calculus, we will refer to meta-level types as
\emph{sets}.  Consequently, the colon $:$
takes the role of elementhood $\in$ in set-theory, and we are free to
reuse the symbol $\in$ for other purposes.

\subsection{Contexts and indices}

We adapt a categorical aka de Bruijn style for the abstract syntax of
terms, which we conceive as intrinsically well-typed.  In de Bruijn
style, a context $\Gamma$ is just a snoc list of simple types $A$,
meaning we write context extension as $\cext \Gamma A$, and the empty
context as $\cempty$.  Membership \fbox{$A \in \Gamma$} and sublist
relations \fbox{$\Gamma \sublist \Delta$} are given inductively by the
following rules:
\begin{gather*}
  \nru{\tzero}{}{A \in \cext \Gamma A}
\qquad
  \nru{\tsuc}{A \in \Gamma}{A \in \cext \Gamma B}
\qquad
  \nru{\tdone}{}{\cempty \sublist \cempty}
\qquad
  \nru{\tlift}
    {\Gamma \sublist \Delta}
    {\cext \Gamma A \sublist \cext \Delta A}
\qquad
  \nru{\tweak}
    {\Gamma \sublist \Delta}
    {\Gamma \sublist \cext \Delta A}
\end{gather*}
We consider the rules as introductions of the indexed types
$\_{\in}\_$ and $\_{\sublist}\_$ and the rule names as constructors.
For instance, $\suc \tzero : A \in \cext {\cext \Gamma A} B$ for any
$\Gamma$, $A$, and $B$; and if we read $\tsuc^n\,\tzero$ as unary
number $n$, then $x : A \in \Gamma$ is exactly the (de Bruijn) index
of $A$ in $\Gamma$.

We can define
\fbox{$\tid : \Gamma \sublist \Gamma$} and \fbox{$\_{\rcomp}\_ : \Gamma
\sublist \Delta \to \Delta \sublist \Phi \to \Gamma \sublist \Phi$}
by recursion, meaning that the (proof-relevant)
sublist relation is reflexive and transitive.
% The sublist relation is reflexive and transitive, the witnesses
% \fbox{$\tid : \Gamma \sublist \Gamma$} and \fbox{$\_{\rcomp}\_ : \Gamma
% \sublist \Delta \to \Delta \sublist \Phi \to \Gamma \sublist \Phi$}
% have easy recursive definitions.
Thus, lists $\Gamma$ form a category
$\Cxt$ with morphisms $\tau : \Gamma \sublist \Delta$, and the category laws
hold propositionally, e.g., we have $\id \rcomp \tau \equiv \tau$ in
propositional equality for all morphisms $\tau$.

The category $\Cxt$ allows us to consider $A{\in}\_$ as a presheaf over
$\Cxt\op$ for any $A$, witnessed by \fbox{$\treindex : \Gamma \sublist
  \Delta \to A \in \Gamma \to A \in \Delta$}, which is the morphism
part of functor from $\Cxt$ to $\Set$, mapping object $\Gamma$ to the
set $A \in \Gamma$ of the indices of $A$ in $\Gamma$.
The associated naturality laws \fbox{$\treindex\,\tid\,x \equiv x$}
and \fbox{$\treindex\,\tau_2\,(\treindex\,\tau_1\,x) \equiv
\treindex\,(\tau_1 \rcomp \tau_2)\,x$} hold propositionally.

\subsection{STLC and its normal forms}

Simple types shall be distinguished into positive types $P$ and
negative types $N$, depending on their root type former.  Function
($\To$) and product types ($\times$ and $\tyone$) are negative,
while base types ($\tybase$) and sum types ($+$ and $\tyzero$) are positive.
\[
\begin{array}{lrl@{\qquad}l}
  A,B,C & ::= & P \mid N & \mbox{simple types} \\
  P     & ::= & \tyzero \mid A + B \mid \tybase & \mbox{positive types} \\
  N     & ::= & \tyone \mid A \times B \mid A \To B
  % P     & ::= & a \mid A + B \mid \tyzero & \mbox{positive types} \\
  % N     & ::= & A \To B \mid A \times B \mid \tyone
    & \mbox{negative types} \\
\end{array}
\]
% Simple types shall be given by the grammar
% % \fbox{$S,T ::= P \mid S \To T \mid S \times T \mid \tyone \mid S + T
% %   \mid \tyzero$}.
% \fbox{$A,B,C ::= a \mid A \To B \mid A \times B \mid \tyone \mid A + B
%   \mid \tyzero$}.
% Herein, $a$ ranges over atomic types aka base types.
Intrinsically well-typed lambda-terms, in abstract syntax,
are just inhabitants $t$ of the type \fbox{$A \from \Gamma$},
inductively defined by the following rules.
\begin{gather*}
  \nru{\tvar}{A \in \Gamma}{A \from \Gamma}
\qquad
  \nru{\tabs}{B \from \cext \Gamma A}{A \To B \from \Gamma}
\qquad
  \nru{\tapp}
    {A \To B \from \Gamma \qquad A \from \Gamma}
    {B \from \Gamma}
\\[2ex]
  \nru{\tunit}{}{\tyone \from \Gamma}
\qquad
  \nru{\tpair}
    {A_1 \from \Gamma \qquad A_2 \from \Gamma}
    {A_1 \times A_2 \from \Gamma}
\qquad
  \nru{\tprj_i}
    {A_1 \times A_2 \from \Gamma}
    {A_i \from \Gamma}
\\[2ex]
  \nru{\tinj_i}
    {A_i \from \Gamma}
    {A_1 + A_2 \from \Gamma}
\qquad
  \nru{\tcase}
    {A_1 + A_2 \from \Gamma
      \qquad C \from \cext \Gamma A_1
      \qquad C \from \cext \Gamma A_2
    }{C \from \Gamma}
\qquad
  \nru{\tabort}
    {\tyzero \from \Gamma}
    {C \from \Gamma}
\end{gather*}
The skilled eye of the reader will immediately recognize the proof
rules of intuitionistic propositional logic (IPL) under the
Curry-Howard isomorphism.  A term such as
\(
  \tabs\,(\tabs\,(\tpair\,
    (\tvar\,(\tsuc\,\tzero))\,
    (\tabs\,(\tapp\,(\tvar\,(\tsuc\,\tzero))\,(\tvar\,\tzero)))))
\)
could in concrete syntax be rendered as
\(
  \lambda x.\,\lambda y.\,(x,\,\lambda z.\,y\,z)
  .
\)
We leave the exact connection to a printable
syntax of the STLC to imagination of the reader,
as we shall not be concerned with considering
concrete terms in this article.

Terms of type $A$ form a presheaf
$A{\from}\_$ as witnessed by the standard weakening operation%
\footnote{Here, $\tren$ is short for \emph{renaming}, but in a nameless
calculus we should better speak of \emph{reindexing}, which could, a
bit clumsily, also abbreviated to $\tren$.}
\fbox{$\tren : \Gamma \sublist \Delta \to A \from \Gamma \to A \from \Delta$}
defined by recursion over $t : A \from \Gamma$,
and naturality laws for $\tren$ analogously to $\treindex$.

Normal forms%
\footnote{%
There is also a stronger
notion of normal form, requiring that two \emph{extensionally equal}
lambda-terms, \ie, those that denote the
same set-theoretical function, have the same normal form
\cite{mitchell:foundations,altenkirchDybjerHofmannScott:lics01,scherer:popl17}.
Such normal forms do not have a simple inductive definition, and we
shall not consider them in this article.
}
are logically characterized as those fulfilling the
\emph{subformula} property \cite{prawitz:natded,matthes:shortproofs}.
Normal forms \fbox{$t : \tNf A\, \Gamma$} are mutually defined with
\emph{neutral} normal forms \fbox{$t : \Ne A \Gamma$}.
In the following inductive definition, we reuse the rule names from the
term constructors.
\begin{gather*}
  \nru{\tvar}{A \in \Gamma}{\Ne A \Gamma}
\qquad
  \nru{\tabs}{\NfC B {\cext \Gamma A}}{\NfP {A \To B} \Gamma}
\qquad
  \nru{\tapp}
    {\NeP {A \To B} \Gamma \qquad \Nf A \Gamma}
    {\Ne B \Gamma}
\qquad
  \nru{\tne}{\Ne \tybase \Gamma}{\Nf \tybase \Gamma}
\\[2ex]
  \nru{\tunit}{}{\Nf \tyone \Gamma}
\qquad
  \nru{\tpair}
    {\Nf {A_1} \Gamma \qquad \Nf {A_2} \Gamma}
    {\NfP {A_1 \times A_2} \Gamma}
\qquad
  \nru{\tprj_i}
    {\NeP {A_1 \times A_2} \Gamma}
    {\Ne {A_i} \Gamma}
\\[2ex]
  \nru{\tinj_i}
    {\Nf {A_i} \Gamma}
    {\NfP {A_1 + A_2} \Gamma}
\quad
  \nru{\tcase}
    {\NeP {A_1 + A_2} \Gamma
      \quad \NfC P {\cext \Gamma A_1}
      \quad \NfC P {\cext \Gamma A_2}
    }{\Nf P \Gamma}
\quad
  \nru{\tabort}
    {\Ne \tyzero \Gamma}
    {\Nf P \Gamma}
\end{gather*}
These rules only allow the elimination of neutrals; guarantees
the subformula property and prevents any kind of computational
($\beta$) redex.
The new rule $\tne$ embeds $\tNe$ into $\tNf$,
but only at base types $\tybase$.
Further, case distintion via $\tcase$ and $\tabort$
is restricted to positive types $P$.
As a consequence, our normal forms are
\emph{$\eta$-long}, meaning that any normal inhabitant of a negative
type is a respective introduction ($\tabs$, $\tunit$, or $\tpair$).
This justifies the attribute \emph{negative} for these types:
the construction of their inhabitants proceeds mechanically, without
any choices.  In contrast, to construct an inhabitant of a
\emph{positive} type choice is required: whether case distinction is
required, and which introduction to pick in the end ($\tinj_1$ or $\tinj_2$).

Needless to say, $\tNe\,A$ and
$\tNf\,A$ are presheaves, \ie, support reindexing with $\tren$ just as terms do.
From a normal form we can extract the term via an overloaded function
\fbox{$\tm\_ : \Nf A \Gamma \to A \from \Gamma$} and
\fbox{$\tm\_ : \Ne A \Gamma \to A \from \Gamma$}
that discards constructor $\tne$ but keeps all other constructors.
This erasure function naturally commutes with reindexing, making it a
natural transformation between the presheaves $\tNf\,A$ ($\tNe\,A$,
resp.) and $A{\from}\_$.  We shall simply write, for instance,
\fbox{$\tNf\,A \todot A{\from}\_$} for such presheaf morphisms.
(The point on the arrow is mnemoic for \emph{pointwise}.)

While the coproduct eliminations $\tcase$ and $\tabort$ are limited to
normal forms of positive types $P$, their extension to negative types
is admissible.
\[
\begin{array}{l@{~}lcl}
  \multicolumn 4 l {\tabort^B ~:~ \tNe\, 0 \todot \tNf\,B} \\
  \tabort^{\tyone}     & u & = & \tunit \\
  \tabort^{A \times B} & u & = & \tpair\,(\tabort^A\,u)\,(\tabort^B\,u) \\
  \tabort^{A \To B}    & u & = & \tabs\,(\tabort^B\,(\tren\,\twk^A\,u)) \\
  \tabort^P           & u & = & \tabort\;u \\
\end{array}
\]
$\tcase$ generalizes analogously, with a bit of care when weakening
the branches.

\emph{Proof normalization} is concerned with finding a normal form
$u : \Nf A \Gamma$ for each derivation $t : A \from \Gamma$.  However,
\emph{term normalization} additionally requires that $\tm u \cong t$
with respect to a equational theory $\cong$ on terms.

\subsection{Proof normalization}

For didactical purposes, let us first focus on the simpler task of
constructing a normalization function
\fbox{$\tnorm : A \from \Gamma \to \Nf A \Gamma$}
that does not guarantee any relation between its input term $t$ and
output normal form $u$.
% \emph{Normalization by evaluation} (NbE) decomposes normalization as
% \fbox{\(
%   \norm[\Gamma] A (t : A \from \Gamma)
%   = \down[\Gamma] A \dent t {\idenv\Gamma}
% \)}
% which is
% \emph{evaluation}
% \nofbox{$\dent \_ \_ : (t : A \from \Gamma) \to \Den \Gamma \Delta \to
%   \Den A \Delta$}
% in the identity environment \nofbox{$\idenv\Gamma : \Den \Gamma \Gamma$}
% followed by
% \emph{reification}
% \nofbox{$\downG A : \Den A \Gamma \to \Nf A \Gamma$}.
\emph{Normalization by evaluation} (NbE) decomposes normalization as
\fbox{\(
%  \norm[\Gamma] A (t : A \from \Gamma)
  \tnorm\, (t : A \from \Gamma)
  = \down A \dent t {\idenv\Gamma}
\)}
which is
\emph{evaluation}
\nofbox{$\dent \_ \_ : (t : A \from \Gamma) \to \den \Gamma \todot
  \den A$}
in the identity environment \nofbox{$\idenv\Gamma : \den \Gamma \Gamma$}
followed by
\emph{reification}
\nofbox{$\down A : \den A \todot \tNf A$}.
The role of evaluation is to produce from a term the corresponding
semantic (\ie, meta-theoretic) function, which is finally reified to a normal form.
Since we are evaluating open terms $t$, we need to supply an environment
$\idenv\Gamma$ which will map the free indices of $t$ to corresponding
\emph{unknowns}.  To accomodate unknowns in the semantics, types $A$
are mapped to presheaves $\den A$ (rather than just sets), and in
particular each base type $\tybase$ is mapped to the presheaf
$\tNe\,\tybase$ with the intention that the neutrals take the role of
the unknowns.  The mapping $\up A : \tNe\,A \todot \den A$ from
neutrals to unknowns is called \emph{reflection}, and defined mutually
with reification by induction on type $A$.

At this point, let us fix some notation for sets to prepare for some
constructions of presheaves.  Let $\bone$ denote the unit set and
$\ttempty$ its unique inhabitant, $\bzero$ the empty set and
$\tmagic : \bzero \to T$ the \emph{ex falsum quod libet} elimination
into any set $T$.  Given sets $S_1$ and $S_2$, their Cartesian product
is written $S_1 \btimes S_2$ with projections $\pi_i : S_1 \btimes S_2
\to S_i$, and their disjoint sum $S_1 \bplus S_2$ with injections
$\iota_i : S_i \to S_1 \bplus S_2$ and elimination $[f_1,f_2] : S_1 \bplus
S_2 \to T$ for arbitrary $f_i : S_i \to T$.

Presheafs (co)products $\hat0$, $\hat1$, $\hatplus$, and $\hattimes$ are
constructed pointwise, \eg, $\hat0\,\Gamma = \bzero$, and given two
presheaves $\A$ and $\B$,
$(\A \hatplus \B)\,\Gamma = \A\,\Gamma \bplus \B\,\Gamma$.  For the
exponential of presheaves, however, we need the \emph{Kripke function
  space}
$(\A \hatto \B)\,\Gamma = \forall \Delta.\, \Gamma \sublist \Delta
\to \A\,\Delta \to \B\,\Delta$.

We will interpret simple types $A$ as corresponding presheaves
$\den A$.  Let us start with the negative types, defining
reflection $\up A : \tNe\, A \todot \den A$
and reification $\down A : \den A \todot \tNf A$ along the way.
\begin{gather*}
\begin{array}{lcl}
  \den   \tyone          & = & \hatone \\
  \upG   \tyone \; u     & = & \ttempty \\
  \downG \tyone \ttempty & = & \tunit \\
\end{array}
\qquad\qquad\qquad
\begin{array}{lcl}
  \den   {A \times B}       & = & \den A \hattimes \den B \\
  \upG   {A \times B} \; u  & = & (\upG A (\prj1 u),\;\upG B (\prj2 u)) \\
  \downG {A \times B} (a,b) & = & \tpair\,(\downG A a)\,(\downG B b) \\
\end{array}
\\[2ex]
\begin{array}{lcl}
  \den {A \To B}    & = & \den A \hatto \den B \\
  \upG   {A \To B}    \; u \; (\tau : \Gamma \sublist \Delta) \; (a : \den A \Delta)
     & = & \up[\Delta] B (\tapp\;(\tren\,\tau\, u)\;(\down[\Delta] A a)) \\
  \downG {A \To B}    f        & = & \tabs\,(\down[\cext \Gamma A] B
    (f\;\twk^A_\Gamma\;\tfresh^A_\Gamma))
\end{array}
\end{gather*}
% We will interpret simple types $A$ as corresponding presheaves
% $\den A$.  Let us start with the negative types:
% \[
% \begin{array}{lcl}
%   \den \tyone       & = & \hatone \\
%   \den {A \times B} & = & \den A \hattimes \den B \\
%   \den {A \To B}    & = & \den A \hatto \den B \\
% \end{array}
% \]
% Reflection $\up A : \tNe\, A \todot \den A$
% and reification $\down A : \den A \todot \tNf A$
% are defined mutually by induction on type $A$.
% \begin{gather*}
% \begin{array}{lcl@{\qquad}lcl}
%   \upG   \tyone       u        & = & \ttempty &
%   \downG \tyone       \ttempty & = & \tunit \\
%   \upG   {A \times B} u        & = & (\upG A (\prj1 u),\;\upG B (\prj2 u)) &
%   \downG {A \times B} (a,b)    & = & \tpair\,(\downG A a)\,(\downG B b) \\
% \end{array}
% \\
% \begin{array}{lcl@{\qquad}lcl}
%   \upG   {A \To B}    u \; (\tau : \Gamma \sublist \Delta) \; (a : \den A \Delta)
%      & = & \up[\Delta] B (\tapp\;(\tren\;\tau\; u)\;(\down[\Delta] A a)) \\
%   \downG {A \To B}    f        & = & \tabs\,(\down[\cext \Gamma A] B
%     (f\,(\twk^A)\,(\tfresh^A_\Gamma)))
% \end{array}
% \end{gather*}
In the equation for $\down{A \To B}$,
the renaming $\twk : \Gamma \sublist \cext \Gamma A$,
defined by $\twk = \tweak\,\tid$, makes room
for a new variable of type $A$, which is reflected into $\den A$ by
\[
\begin{array}{lcl@{\qquad}lcl}
  \tfresh : \den A (\cext \Gamma A) \\
  \tfresh = \up[\cext \Gamma A] A (\tvar\;\tzero)
  . \\
\end{array}
\]
The ability to introduce fresh variables into a context, and to use
semantic objects such as $f : \den{A \To B}\Gamma$ in a such extended
context, is the reason for utilizing presheaves instead of just sets.

Note also that in the equation for $\up{A \To B}$,
the neutral $u : \Ne A \Gamma$ is
transported into $\Ne A \Gamma$ via reindexing with
$\tau : \Gamma \sublist \Delta$, in order to be applicable to the normal form
$\down[\Delta]A a$
reified from the semantic value $a$.

A direct extension of our presheaf semantics to positive types cannot
work.  For instance, with $\den \tyzero = \hat0$, simply
$\up[\tyzero] \tyzero (\tvar\,\tzero) : \bzero$ would give us an
inhabitant of the empty set, which means that reflection at the empty
type would not be definable.  Similarily, the setting
$\den{A + B} = \den A \hatplus \den B$ is refuted by
% $\up[\tyone + \tyone]^{\tyone + \tyone} (\tvar\,\tzero) : \bone \bplus \bone$
$\up[A + B]{A + B} (\tvar\,\tzero) : \den A (A+B) \bplus \den B (A+B)$
which would require us to make a decision of whether $A$ holds or $B$ holds
while only be given a hypothesis of type $A + B$.
Not even the usual interpretation of base types $\den o = \tNe\,o$
works in the presence of sums, as we would not be able to interpret
the term
$\tabs\,(\tcase\,(\tvar\,\tzero)\,(\tvar\,\tzero)\,(\tvar\,\tzero)) :
(o+o) \To o$ in our semantics, as $\Ne o (o+o)$ is empty.
What is needed are case distinctions on neutrals in the semantics,
allowing us the elimination of positive hypotheses before producing a
semantic value,
and we shall capture this capability in a strong monad $\C$
which can \emph{cover} the cases.

To recapitulate, a monad $\C$ on presheaves is first an endofunctor,
i.e., it maps any presheaf $\A$ to the presheaf $\C\,\A$ and any
presheaf morphism $f : \A \todot \B$ to the morphism
$\tmap[\C]f: \C\,\A \todot \C\;\B$ satisfying the functor laws for
identity and composition.  Then, there are natural transformations
$\treturn[\C] : \A \todot \C\,\A$ (unit) and
$\tjoin[\C] : \C\,(\C\,\A) \todot \C\,\A$ (concatenation) satisfying
the monad laws.

We are looking for a cover monad $\C$ that
offers us these services:
% \begin{enumerate}
% \item Elimination of absurd neutrals
% $\tabort^\C : \tNe\, \tyzero \todot \C\,\A$.
% \item Case distinction on neutrals of sum type
% $\tcase^\C_\Gamma : \Ne {(A + B)} \Gamma
%   \to \C\,\A\,(\cext \Gamma A)
%   \to \C\,\A\,(\cext \Gamma B)
%   \to \C\,\A\,\Gamma$.
% \item Run the monad to produce a normal form
% $\trun^\C : \C\,(\Nf A) \todot \Nf A$.
% \end{enumerate}
\[
\begin{array}{lcl@{\quad}l}
\tabort^\C & : & \tNe\, \tyzero \todot \C\,\A
  & \mbox{case on absurd neutral} \\
\tcase^\C_\Gamma & : & \Ne {(A + B)} \Gamma
  \to \C\,\A\,(\cext \Gamma A)
  \to \C\,\A\,(\cext \Gamma B)
  \to \C\,\A\,\Gamma
  & \mbox{case on neutral} \\
\trunNf[\C] & : & \C\,(\tNf A) \todot \tNf A
  & \mbox{run the monad ($\tNf$ only)} \\
\end{array}
\]
To make things concrete,
we shall immediately construct an instance of such a cover monad:
the free cover monad
$\Cov$ defined inductively by $\treturn[\Cov]$, $\tabort^{\Cov}$, and
$\tcase^{\Cov}$.  One can visualize an element $c : \Cov\,\A\,\Gamma$ as
binary case tree whose inner nodes ($\tcase$) are labeled by a neutral term
of sum type $A+B$ and its two branches by the context extensions $A$
and $B$, resp.  Leaves are either ($\tabort$)
labeled by a neutral term of empty type $\tyzero$,
or ($\treturn$) by an element of $\A$.  Functoriality amounts to
replacing the labels of the $\treturn$-leaves, and the monadic bind replaces
these leaves by further case trees.  (The uninspiring $\tjoin[\Cov]$
flattens a 2-level case tree into a single one.)
Finally $\trunNf[\Cov]$ is a simple recursion, replacing $\tcase^{\Cov}$
and $\tabort^{\Cov}$
by the $\tcase$ and $\tabort$ constructions on normal forms, and
$\treturn[\Cov]$ by the identity.

% the following constructions:
% \begin{gather*}
%   \nru{\treturn[\Cov]}{\A\,\Gamma}{\Cov\,\A\,\Gamma}
% \end{gather*}

Using the services of a generic cover monad $\C$, we can complete our semantics:
%\begin{gather*}
\[
\begin{array}{lcl}
  \den   \tybase & = & \C\,(\tNe\,\tybase) \\
  \upG   \tybase & = & \treturn[\C] \\
  \downG \tybase & = & \trunNf[\C] \comp \tmap[\C]\tne \\
\end{array}
\qquad
\begin{array}{lcl}
  \den   \tyzero & = & \C\,\hat0 \\
  \upG   \tyzero & = & \tabort^\C \\
  \downG \tyzero & = & \trunNf[\C] \comp \tmap[\C]\tmagic \\
\end{array}
\]
% \[
% \begin{array}{lcl}
%   \den \tybase & = & \C\,(\tNe\,\tybase) \\
%   \upG \tybase \; u & = & \treturn[\C]\,u \\
%   \downG \tybase \; m & = & \trunNf[\C]\,(\tmap[\C]\tne\;m) \\
% \end{array}
% \qquad
% \begin{array}{lcl}
%   \den \tyzero & = & \C\,\hat0 \\
%   \upG \tyzero \; u & = & \tabort^\C\,u \\
%   \downG \tyzero \; m & = & \trunNf[\C]\,(\tmap[\C]\tmagic\;m) \\
% \end{array}
% \]
\[
\begin{array}{lcl}
  \den {A+B} & = & \C\,(\den A \hatplus \den B) \\
  \upG {A+B} \; u & = & \tcase^\C\,u
    \,(\treturn[\C]\,(\iota_1\,\tfresh^A_\Gamma))
    \,(\treturn[\C]\,(\iota_2\,\tfresh^B_\Gamma))
    \\
  \downG {A+B} & = & \trunNf[\C] \comp
    \tmap[\C] [\tinj_1 \comp \down A,\; \tinj_2 \comp \down B] \\
\end{array}
\]
% \[
% \begin{array}{lcl}
%   \den {A+B} & = & \C\,(\den A \hatplus \den B) \\
%   \upG {A+B} \; u & = & \tcase^\C\,u
%     \,(\treturn[\C]\,(\iota_1\,\tfresh^A_\Gamma))
%     \,(\treturn[\C]\,(\iota_2\,\tfresh^B_\Gamma))
%     \\
%   \downG {A+B} \; m & = & \trunNf[\C]\,
%     (\tmap[\C] [\tinj_1 \comp \down A,\; \tinj_2 \comp \down B]\;m) \\
% \end{array}
% \]
%\end{gather*}

All semantic types fulfill the weak sheaf condition aka weak pasting,
meaning there is
a natural transformation $\trun^A : \C\,\den A \todot \den A$ for any simple
type $A$.  In other words, we can \emph{run} the monad, pushing its
effects into $\den A$.  We proceed by induction on $A$.
Positive types $P$ are already monadic,
and $\trun^P$ is simply the $\tjoin$ of monad $\C$.
At negative types we can recurse pointwise at a smaller type,
exploiting that values of negative types are essentially
(finite or infinite) tuples.
\[
\begin{array}{l@{~}l@{~~}c@{~~}l@{\qquad}l@{~~}c@{~~}l}
  \multicolumn 7 l {\trun^A ~:~ \C \den A \todot \den A} \\
  \trun^{\tyone} & c & = & \ttempty
    &
  \trun^{\tyzero} & = & \tjoin[\C]
    \\
  \trun^{A \times B} & c & = &
      (\trun^A\,(\tmap[\C]\;\pi_1\;c),\
       \trun^B\,(\tmap[\C]\;\pi_2\;c))
    &
  \trun^{A + B}   & = & \tjoin[\C]
  \\
  \trun^{A \To B} & c \; \tau \; a & = & \trun^B\,
      (\stmap[\C]\;(\lambda\;\tau'\,f.\;f\;\tid\;(\tren\;\tau'\;a))\;(\tren\;\tau\;c))
    &
  \trun^{o}      & = & \tjoin[\C]
\\
\end{array}
% \begin{array}{lcl@{\quad}l@{~}lcl}
%   \trun^A & : & \C \den A \todot \den A \\
%   \trun^{\tyzero} & = & \tjoin[\C]
%     & \trun^{\tyone} & c & = & \ttempty \\
%   \trun^{A + B}   & = & \tjoin[\C]
%     & \trun^{A \times B} & c & = &
%       (\trun^A\,(\tmap[\C]\;\pi_1\;c),\
%        \trun^B\,(\tmap[\C]\;\pi_2\;c))\\
%   \trun^{o}      & = & \tjoin[\C]
%     & \trun^{A \To B} & c \; \tau \; a & = & \trun^B\,
%       (\stmap[\C]\;(\lambda\;\tau'\,f.\;f\;\tid\;(\tren\;\tau'\;a))\;(\tren\;\tau\;c))
% \\
% \end{array}
\]
For the case of function types $A \To B$, we require the monad $\C$ to be
\emph{strong}, which amounts to having
$\stmap[\C]_\Gamma\, \ell : \C\A\,\Gamma \to \C\,\B\,\Gamma$ already for
a local presheaf morphism $\ell : (\A \hatto \B)\Gamma$.
The typings are
$c : \C \den{A \To B} \Gamma$ and
$\tau : \Gamma \sublist \Delta$ and
$a : \den A \Delta$, and now we want to apply every function
$f : \den{A \To B}$ in the cover $c$ to argument $a$.  Clearly,
$\tmap[\C]$ is not applicable since it would expect a
global presheaf morphism
$\den{A \to B} \todot \den B$, \ie, something that works in \emph{any}
context.  However, applying to $a : \den A \Delta$ can only work in
context $\Delta$ or any extension $\tau' : \Delta \sublist \Phi$,
since we can transport $a$ to such a $\Phi$ via
$a' := \tren\; \tau'\; a : \den A \Phi$ but not to a context unrelated to
$\Delta$.  We obtain our input to $\trun^B$ of type $\C \den B \Gamma$
as an instance of $\stmap[\C]_\Gamma$ applied to the local presheaf morphism
$(\lambda \; \tau'\, f. \  f\;\tid\;a') :
\Delta \sublist \Phi \to  \den{A \To B}\Phi \to \den B \Phi$
% (\tau' : \Delta \sublist \Phi) (f : \den{A \To B}\Phi) \to \den B \Phi$
and the transported cover $\tren\;\tau\;c : \C\den{A \To B}\Delta$.


We extend the type interpretation pointwise to contexts, \ie,
$\den \cempty = \hatone$ and
$\den{\cext \Gamma A} = \den \Gamma \hattimes \den A$
and obtain a natural projection function from the semantic enironments:
\[
\begin{array}{lcl}
  \tlookup\,(x : A \in \Gamma) & : &  \den \Gamma \todot \den A \\
  \tlookup\;\tzero     & = & \pi_2 \\
  \tlookup\;(\tsuc\,x) & = & \tlookup\;x \comp \pi_1 \\
\end{array}
% \begin{array}{lcl}
%   \tlookup & : & A \in \Gamma \to \den \Gamma \todot \den A \\
%   \tlookup\;\tzero     & = & \pi_2 \\
%   \tlookup\;(\tsuc\,x) & = & \tlookup\;x \comp \pi_1 \\
% \end{array}
\]
The evaluation function
\fbox{$\denty {t : A \from \Gamma}  : \den \Gamma \todot \den A$}
% \fbox{$\dent {t : A \from \Gamma} \_ : \den \Gamma \todot \den A$}
can now be defined by recursion on $t$.
Herein the environment $\gamma$ lives in $\den \Gamma \Delta$, thus, $\dent t \gamma : \den A \Delta$.
% Herein, $\gamma : \den \Gamma \Delta$, thus, $\dent t \gamma : \den A \Delta$.
\[
\begin{array}{lcl}
  \dent{\tvar\,x}\gamma & = & \tlookup\,x\,\gamma \\
  \dent{\tabs\,(t : B \from \cext \Gamma A)}\gamma \;
     (\tau : \Delta \sublist \Phi)\, (a : \den A \Phi) & = &
        \dent t {(\tren\,\tau\,\gamma,\ a)} \\
  % \dent{\tabs\,(t : B \from \cext \Gamma A)}\gamma & = &
  %    \lambda\, (\tau : \Delta \sublist \Phi)\, (a : \den A \Phi). \
  %       \dent t {(\tren\,\tau\,\gamma,\ a)} \\
  \dent{\tapp\,t\,u} \gamma & = &
     \dent t \gamma\;\tid\;\dent u \gamma \\
  % \dent{\tapp\,(t : A \To B \from \Gamma)\,u} \gamma & = &
  %    \dent t \gamma\;\tid\;\dent u \gamma \\
  \dent{\tunit}\gamma & = & \ttempty \\
  \dent{\tpair\,t_1\,t_2}\gamma & = &
    (\dent{t_1}\gamma,\ \dent{t_2}\gamma) \\
  \dent{\prj i t}\gamma & = & \pi_i \dent t \gamma \\
  \dent{\inj i t}\gamma & = & \iota_i \dent t \gamma \\
  \dent{\tabort\,u}\gamma & = & \denabort\;\dent u \gamma \\
  \dent{\tcase\,(u : A_1 + A_2 \from \Gamma)\;t_1\;t_2}\gamma & = &
     \dencase\;\dent u \gamma\;f_1\;f_2
    \ \mbox{ \textbf{where}} \\
    \multicolumn 1 r {f_i\; (\tau : \Delta \sublist \Phi)\,(a_i : \den {A_i} \Phi)}
        & = &
        \dent {t_i} {(\tren\;\tau\;\gamma,\ {a_i})}
   % \
   %  (\lambda\; (\tau : \Delta \sublist \Phi)\,(b : \den A \Phi).\
   %      \dent v {(\tren\;\tau\;\gamma,\ b)})
    \\
\end{array}
\]
The coproduct eliminations $\denabort$ and $\dencase$
targeting an arbitrary semantic type $\den B$ are definable thanks to
the weak sheaf property, \ie, the presence of pasting via $\trun^B$
for any type $B$, and strong functoriality of $\C$.
\[
\begin{array}{lcl}
  \denabort^B & : & \den \tyzero \todot \den B \\
  \denabort^B & = & \trun^B \comp \tmap[\C]\,\tmagic
\\[2ex]
  \dencase^B_\Gamma  & : & \den{A_1 + A_2}\Gamma
    \to \den{A_1 \To B}\Gamma
    \to \den{A_2 \To B}\Gamma
    \to \den{B}\Gamma \\
  \dencase^B_\Gamma\;c\;f_1\;f_2 & = &
    \trun^B (\stmap[\C]\;(\lambda\,\tau.\ [f_1\,\tau,\ f_2\,\tau])\;c) \\
\end{array}
\]
To complete the normalization function
$\tnorm\,(t : A \from \Gamma) = \downG A \dent t {\idenv \Gamma}$
we define the identity environment $\idenv \Gamma : \den \Gamma \Gamma$,
which maps each free index to its corresponding unknown in the
semantics, by recursion on $\Gamma$:
\[
\begin{array}{lcl}
  \idenv \cempty & = & \ttempty \\
  \idenv {\cext \Gamma A} & = & (\tren\;\twk^A\,\idenv\Gamma, \  \tfresh^A_\Gamma)\\
\end{array}
\]

\subsection{Continuation monad}



\clearpage

\subsection{Term normalization}

Defining%
\footnote{%
A more accurate presentation of $\tNF$ would be
$\sum_{u : \tNf A\,\Gamma} (\tm u \cong t)$
in order to make absolutely clear that we
want get hold of the witness $u$ of the existential statement;
however, we shall only use constructive
existentials
in this article and thus stick to the notation $\exists$.
We mean \emph{constructive existence} in
  contrast to classical existence and
  \emph{mere existence} from Homotopy Type Theory which
  requires propositional truncation.
}
\fbox{$\NF t = \exists u \of \tNf A\,\Gamma.\; \tm u \cong t$}
% for $t : A \from \Gamma$,
we aim to construct a normalization function
\[
  \tnorm : (t : A \from \Gamma) \to \NF t
\]
that gives us for each term $t$ a $\cong$-equal normal form $u$.

\section{Call-By-Push Value}
\label{sec:cbpv}

\section{Focused Intuitionistic Propositional Logic}
\label{sec:fipl}

Polarized lambda calculus \cite{espiritoSanto:entcs17}
divides types deeply into positive and negative.

\[
\begin{array}{lllrl@{\qquad}l}
  \PTy & \ni & P,Q & ::= & \patom
    \mid \tyzero \mid P_1 + P_2
    \mid \tyone \mid P_1 \times P_2
    \mid \Thunk N
  & \mbox{positive type}
\\
  \NTy & \ni & N,M & ::= & \natom
    \mid \top \mid N_1 \ntimes N_2
    \mid P \To N
    \mid \Comp P
  & \mbox{negative type}
\\
  \HTy & \ni & X,Y & ::= & \patom \mid P
  & \mbox{hypothesis type}
\\
\end{array}
\]
Espirito Santo's version actually does not contain the positive
product $\times$, however, it appears in Zeilberger
\cite{zeilberger:PhD}.

Polarized lambda-calculus is a focused calculus, it eagerly employs
invertible rules: the introduction rules for negative types and the
elimination rules for positive types.  As a consequence of the latter,
variables are either of atomic or negative type ($\HTy$).
Contexts $\Gamma,\Delta$ are lists of $\HTy$s.
%\fbox{$X ::= \patom \mid P$}.

To add a variable of positive type $P$ to the context, we need to
break it apart until only atoms and negative bits remain.  This is
performed by maximal pattern matching, called the left-invertible
phase of focalization.
We express maximal pattern matching on $P$ as a strong functor
$\Add P$ in the category of presheaves
mapping a presheaf $\J$ (``judgement'') to $\Add P \J$
and a presheaf morphism $f : (\J \hatto \K)\Gamma$ to
$\stmap[\Add P]_\Gamma f : \AddHyp P \J \Gamma \to \AddHyp P \K \Gamma$.
For arbitrary $\J$ and $\Gamma$, the set \fbox{$\AddHyp P \J \Gamma$} is
inductively constructed by the following rules:
\begin{gather*}
  \nru{\phyp}
      {\J\,(\cext \Gamma \patom)}
      {\AddHyp {\patom} \J \Gamma}
\qquad
  \nru{\nbranch}
      {}
      {\AddHyp {\tyzero} \J \Gamma}
\qquad
  \nru{\bbranch}
      {\AddHyp {P_1} \J \Gamma \qquad
       \AddHyp {P_2} \J \Gamma }
      {\AddHyp {P_1 + P_2} \J \Gamma}
\\[2ex]
  \nru{\nhyp}
      {\J\,(\cext \Gamma N)}
      {\AddHyp {\Thunk N} \J \Gamma}
\qquad
  \nru{\nsplit}
      {\J\,\Gamma}
      {\AddHyp {\tyone} \J \Gamma}
\qquad
  \nru{\bsplit}
      {\AddHyp {P_1} {(\Add{P_2}\,\J)} \Gamma}
      {\AddHyp {P_1 \times P_2} \J \Gamma}
\end{gather*}
Note the recursive occurrence of $\Add{P_2}$ as argument to
$\Add{P_1}$ in $\bsplit$, which makes $\Add P$ a nested datatype
\cite{bird:nested}.  Agda supports such nested inductive types; but
note that $\Add{P}$ is uncontroversial, since it could also be defined
by recursion on $P$.   It is tempting to name $\bsplit$
``$\tjoin$'' and $\nsplit$ ``$\treturn$''
since $\Add P$ is a graded monad on the monoid $(1,\times)$
of product types;
however, this coincidence shall not matter for our further considerations.

In the following, we mutually define the inductive families of
presheaves $\tVal\,P$,
$\tNe\,N$, $\Cov\,\J$,
and $\tNf\,N$.

Values \fbox{$v : \PVal P \Gamma$}
of positive type $P$ are constructed by the
following rules:
\begin{gather*}
  \nru{\pvar}{P \in \Gamma}{\PVal P \Gamma}
\qquad
  \nru{\tthunk}{\Nf N \Gamma}{\PValP{\Thunk\,N}\Gamma}
\\[2ex]
  \nru{\punit}{}{\PVal{\tyone}\Gamma}
\qquad
  \nru{\ppair}
      {\PVal{P_1}\Gamma \qquad \PVal{P_2}\Gamma}
      {\PValP{P_1 \times P_2}\Gamma}
\qquad
  \nru{\tinj_i}{\PVal{P_i}\Gamma}{\PValP{P_1 + P_2}\Gamma}
\end{gather*}
Negative hypotheses can be eliminated by projections and application
to values, as described by the following inductive family
\fbox{$\Ne N \Gamma$}:
\begin{gather*}
  \nru{\nvar}{N \in \Gamma}{\Ne N \Gamma}
\qquad
  \nru{\tprj_i}
      {\NeP {N_1 \ntimes N_2} \Gamma}
      {\Ne {N_i} \Gamma}
\qquad
  \nru{\tapp}
      {\NeP {P \To N} \Gamma \qquad \PVal P \Gamma}
      {\Ne N \Gamma}
\end{gather*}
An elimination may either result in a negative atom $\natom$ or a
positive type $P$, which can be further taken apart by pattern
matching.  Pattern matching on neutrals is organized in the
inductively defined strong monad \fbox{$\Cov$}.
\begin{gather*}
  \nru{\treturn}{\J\,\Gamma}{\Cover \J \Gamma}
\qquad
  \nru{\tmatch}
      {\NeP {\Comp\,P} \Gamma \qquad \AddHypP P {\Cov\,\J} \Gamma}
      {\Cover \J \Gamma}
\end{gather*}
Finally, normal forms of negative types are defined as inductive
family \fbox{$\Nf N \Gamma$}.
\begin{gather*}
  \nru{\tne}
      {\CoverP {\tNe\,\natom} \Gamma}
      {\Nf {\natom} \Gamma}
\quad
  \nru{\tval}
      {\CoverP {\tVal\,P}  \Gamma}
      {\NfP {\Comp\,P} \Gamma}
\quad
  \nru{\npair}
      {\Nf {N_1} \Gamma \qquad \Nf {N_2} \Gamma}
      {\NfP {N_1 \ntimes N_2} \Gamma}
\quad
  \nru{\tabs}
      {\AddHypP P {\tNf\, N} \Gamma}
      {\NfP {P \To N} \Gamma}
\end{gather*}
All these inductive families are presheaves, due to factored
presentation using $\Add P$ and $\Cov$ the proof is not a simple
mutual induction.  Yet, in Agda, the generic proof goes through using a sized
typing for these inductive families.  Similarily, defining the
$\tjoin$ for monad $\Cov$ relies on sized typing.
\[
\begin{array}{lll}
  \tjoin & : & \forall i.\
    \Cov[i]\,(\Cov[\infty]\J) \todot \Cov[\infty]\J  \\
  \tjoin[i+1]\,(\treturn[i]\;c) & = & c \\
  \tjoin[i+1]\,(\tmatch^i\;t\;k)
    & = & \tmatch^\infty\;
     (t : \Ne P \Gamma)\;
     (\stmap[\Add P]_\Gamma\;\tjoin[i]\;(k : \AddHypP P {\Cov[i]\J} \Gamma)) \\
  % \tjoin^{i+1}\,(\tmatch\,(t : \Ne P \Gamma)\,
  %   (k : \AddHypP P {\Cov^i\,\J} \Gamma))
  %   & = & \tmatch\;t\;(\stmap[\Add P]_\Gamma\;\tjoin^i\;k) \\
\end{array}
\]
Herein, we used the sized typing of the constructors of $\Cov$:
\[
\begin{array}{lll}
  \treturn & : & \forall i.\ \J \todot \Cov[i+1] \J \\
  \tmatch  & : & \forall i.\
    \tNe\,(\Comp\,P) \todot \Add P\,(\Cov[i]\J) \todot \Cov[i+1]\J \\
\end{array}
\]




\clearpage

\subsection{Parametrized syntax (superseded)}

Assuming a family $\T\,N\,\Gamma$ of terms of negative type $N$ in
context $\Gamma$, values \fbox{$v : \PValT P \Gamma$}
of positive type $P$ are constructed by the
following rules:
\begin{gather*}
  \nru{\pvar}{P \in \Gamma}{\PValT P \Gamma}
\qquad
  \nru{\tthunk}{\T\,N\,\Gamma}{\PValTP{\Thunk\,N}\Gamma}
\\[2ex]
  \nru{\punit}{}{\PValT{\tyone}\Gamma}
\qquad
  \nru{\ppair}
      {\PValT{P_1}\Gamma \qquad \PValT{P_2}\Gamma}
      {\PValTP{P_1 \times P_2}\Gamma}
\qquad
  \nru{\tinj_i}{\PValT{P_i}\Gamma}{\PValTP{P_1 + P_2}\Gamma}
\end{gather*}
Negative hypotheses can be eliminated by projections and application
to values, as described by the following inductive family
\fbox{$\NeT N \Gamma$}:
\begin{gather*}
  \nru{\nvar}{N \in \Gamma}{\NeT N \Gamma}
\qquad
  \nru{\tprj_i}
      {\NeTP {N_1 \ntimes N_2} \Gamma}
      {\NeT {N_i} \Gamma}
\qquad
  \nru{\tapp}
      {\NeTP {P \To N} \Gamma \qquad \PValT P \Gamma}
      {\NeT N \Gamma}
\end{gather*}
% Negative hypotheses can be eliminated by projections and application
% to values $v : \V\,P\,\Gamma$ which we leave abstract in the following
% inductive definition of \fbox{$\Ne[\V] N \Gamma$}:
% \begin{gather*}
%   \nru{\nvar}{N \in \Gamma}{\Ne[\V] N \Gamma}
% \qquad
%   \nru{\tprj_i}
%       {\NeP[\V] {N_1 \ntimes N_2} \Gamma}
%       {\Ne[\V] {N_i} \Gamma}
% \qquad
%   \nru{\tapp}
%       {\NeP[\V] {P \To N} \Gamma \qquad \V\,P\,\Gamma}
%       {\Ne[\V] N \Gamma}
% \end{gather*}

% decomposing
% decomposes
% \emph{values}, meaning inhabitants of positive types.
An elimination may either result in a negative atom $\natom$ or a
positive type $P$, which can be further taken apart by pattern
matching.  Pattern matching on neutrals is organized in the
inductively defined cover monad \fbox{$\Cov[\T]$}.
\begin{gather*}
  \nru{\treturn}{\J\,\Gamma}{\CoverT \J \Gamma}
\qquad
  \nru{\tmatch}
      {\NeTP {\Comp\,P} \Gamma \qquad \AddHypP P {\Cov[\T]\J} \Gamma}
      {\CoverT \J \Gamma}
\end{gather*}

Finally, normal forms of negative types are defined as inductive
family \fbox{$\Nf N \Gamma$}.  It relies on the previous definitions
with instance $\T = \tNf$.
\begin{gather*}
  \nru{\tne}
      {\Cov[\tNf](\tNe[\tNf]\,\natom)\,\Gamma}
      {\Nf {\natom} \Gamma}
\qquad
  \nru{\tval}
      {\Cov[\tNf](\tVal[\tNf]\,P)\,\Gamma}
      {\NfP {\Comp\,P} \Gamma}
\\[2ex]
  \nru{\npair}
      {\Nf {N_1} \Gamma \qquad \Nf {N_2} \Gamma}
      {\NfP {N_1 \ntimes N_2} \Gamma}
\qquad
  \nru{\tabs}
      {\AddHypP P {\tNf\, N} \Gamma}
      {\NfP {P \To N} \Gamma}
\end{gather*}


\section{Conclusion}
\label{sec:concl}

\bibliography{auto-fscd19}

% \appendix

\end{document}
