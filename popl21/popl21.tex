\nonstopmode
%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{5}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{xypic}

\usepackage{dashrule}
\newcommand{\dashruler}{\hdashrule[0.5ex]{\textwidth}{0.2pt}{1ex}}
\newcommand{\ruler}{\rule{\textwidth}{0.2pt}}

% % https://tex.stackexchange.com/questions/46828/how-to-highlight-important-parts-with-a-gray-background
% \usepackage[breakable, theorems, skins]{tcolorbox}
% \tcbset{enhanced}

% \DeclareRobustCommand{\graytextbox}[2][gray!20]{%
% \begin{tcolorbox}[   %% Adjust the following parameters at will.
%         breakable,
%         left=0pt,
%         right=0pt,
%         top=0pt,
%         bottom=0pt,
%         colback=#1,
%         colframe=#1,
%         width=\dimexpr\textwidth\relax,
%         enlarge left by=0mm,
%         boxsep=5pt,
%         arc=0pt,outer arc=0pt,
%         ]
%         #2
% \end{tcolorbox}
% }

% https://tex.stackexchange.com/questions/502652/define-tcolorbox-in-math-mode
\usepackage{tcolorbox}
\newtcbox{\grayboxtext}{on line,colback=gray!20,colframe=gray!20,size=fbox,arc=0pt,boxrule=0pt}%,beforeafter skip=0pt,leftright skip=0pt}
\newcommand{\graybox}[1]{\grayboxtext{$#1$}}

\newtheorem{remark}{Remark}

\begin{document}

%% Title information
\title[Graded CBPV]{Graded Call-By-Push-Value}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Andreas Abel}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-0420-4492}             %% \orcid is optional
\affiliation{
  \department{Department of Computer Science and Engineering}
  \institution{Gothenburg University}
  \streetaddress{Rännvägen 6b}
  \city{Göteborg}
%  \state{State1}
  \postcode{41296}
  \country{Sweden}
}
\email{andreas.abel@@gu.se}          %% \email is recommended

% %% Author with two affiliations and emails.
% \author{First2 Last2}
% \authornote{with author2 note}          %% \authornote is optional;
%                                         %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
% \affiliation{
%   \position{Position2a}
%   \department{Department2a}             %% \department is recommended
%   \institution{Institution2a}           %% \institution is required
%   \streetaddress{Street2a Address2a}
%   \city{City2a}
%   \state{State2a}
%   \postcode{Post-Code2a}
%   \country{Country2a}                   %% \country is recommended
% }
% \email{first2.last2@inst2a.com}         %% \email is recommended
% \affiliation{
%   \position{Position2b}
%   \department{Department2b}             %% \department is recommended
%   \institution{Institution2b}           %% \institution is required
%   \streetaddress{Street3b Address2b}
%   \city{City2b}
%   \state{State2b}
%   \postcode{Post-Code2b}
%   \country{Country2b}                   %% \country is recommended
% }
% \email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Call-by-push-value (CBPV) is a simply typed lambda calculus that polarizes
types into value and computation types and can thus express both
call-by-name and call-by-value evaluation in the presence of effects.
Semantically, effects are modeled by a monad, and computation types as
algebras over this monad.
Effect type systems usually express more information than the presence
of an effect; often effects are categorized by pre-ordered monoid
where the monoid operation represents accumulation of effects and the
order expresses effect subsumption, in analogy to subtyping.
In this work, a \emph{graded} version of CBPV is presented where the typing
of computations likens effect typing.  Semantically, computation types
are then represented as graded monad algebras.
Further we present a version of CBPV which additionally has graded coeffects.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
 \begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010125.10010130</concept_id>
<concept_desc>Theory of computation~Type structures</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010138.10010142</concept_id>
<concept_desc>Theory of computation~Program verification</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010131.10010134</concept_id>
<concept_desc>Theory of computation~Operational semantics</concept_desc>
<concept_significance>100</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Type structures}
\ccsdesc[300]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Operational semantics}
%% End of generated code

%% Keywords
%% comma separated list
\keywords{effects, coeffects, call-by-name, call-by-value, linear types}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Call-by-push-value (CBPV) is a simply typed lambda calculus that polarizes
types into value and computation types and can thus express both
call-by-name and call-by-value evaluation in the presence of effects.
Semantically, effects are modeled by a monad, and computation types as
algebras over this monad.
Effect type systems usually express more information than the presence
of an effect; typically effects are structured as pre-ordered monoid
where the monoid operation represents accumulation of effects and the
order subsumption, in analogy to subtyping.
In this work, a \emph{graded} version of is presented where the typing
of computations likens effect typing.  Semantically, computation types
are then represented as graded monad algebras.
Further we present a version of CBPV which additionally has graded coeffects.


\section{An effect-graded version of CBPV}

%\newcommand{}{\ensuremath{}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\Eg}{\emph{E.g.}}
\newcommand{\loccit}{\emph{loc.\,cit.}}
\newcommand{\den}[2][]{\llbracket#2\rrbracket^{#1}}
\newcommand{\dent}[1]{\llparenthesis#1\rrparenthesis}
\newcommand{\To}{\ensuremath{\Rightarrow}}
%\newcommand{\todot}{\stackrel\cdot\to}
\newcommand{\todot}{\mathbin{\dot{\to}}}
\newcommand{\bN}{\ensuremath{\mathbb{N}}}
\newcommand{\dom}{\mathop{\mathrm{dom}}\nolimits}
\newcommand{\Pot}[1]{\mathcal{P}\,#1}
%\newcommand{\defiff}{:\iff}
\newcommand{\defiff}{\mathrel{{{:}{\Longleftrightarrow}}}}

\newcommand{\denp}{\den[+]}
\newcommand{\denn}{\den[-]}
\newcommand{\Denp}[2]{\denp{#1}_{#2}}
\newcommand{\Denn}[2]{\denn{#1}_{#2}}
\newcommand{\Den}[2]{\den{#1}_{#2}}
\newcommand{\denv}[2]{\dent{#1}_{#2}}

\newcommand{\tEff}{\ensuremath{\mathsf{Eff}}}
\newcommand{\Eff}{\ensuremath{\mathsf{Eff}}}
\newcommand{\bu}{\ensuremath{\bullet}}
\newcommand{\Ge}{\ensuremath{\varepsilon}}
\newcommand{\Ga}{\ensuremath{\alpha}}
\newcommand{\Gd}{\ensuremath{\delta}}
\newcommand{\Gg}{\ensuremath{\gamma}}
\newcommand{\Gl}{\ensuremath{\lambda}}
\newcommand{\Gr}{\ensuremath{\rho}}
\newcommand{\GG}{\ensuremath{\Gamma}}
\newcommand{\GS}{\ensuremath{\Sigma}}
\newcommand{\R}{\mathsf{R}}
\newcommand{\I}{\mathsf{I}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\W}{\mathsf{W}}
\newcommand{\M}{\mathsf{M}}
\newcommand{\wleq}{\sqsubseteq}
\newcommand{\winf}{\sqcap}
\newcommand{\wsup}{\sqcup}
%\newcommand{\winf}{\bigsqcap}
\newcommand{\emp}{0_{\W}}
% \newcommand{\emp}{\varepsilon}
% \newcommand{\emp}{\emptyset}

\newcommand{\CC}{\ensuremath{\mathcal{C}}}
\newcommand{\Hom}[2]{\CC\,(#1,\,#2)}
\newcommand{\SET}{\mathsf{SET}}
\newcommand{\CPO}{\mathsf{CPO}}
\newcommand{\T}[1][]{\mathsf{T}_{#1}}
\newcommand{\D}[1][]{\mathsf{D}_{#1}}
\newcommand{\trun}{\mathsf{run}}
\newcommand{\run}[1][]{\mathsf{run}_{#1}}
\newcommand{\texpose}{\mathsf{expose}}
\newcommand{\expose}[1][]{\texpose_{#1}}
\newcommand{\tA}{\mathsf{A}}
\newcommand{\tB}{\mathsf{B}}
\newcommand{\A}{\mathsf{A}}
\newcommand{\B}{\mathsf{B}}
\newcommand{\tExc}{\mathsf{Exc}}
\newcommand{\Exc}{\mathsf{Exc}}
\newcommand{\String}{\mathsf{String}}
\newcommand{\StringLe}[1]{\mathsf{String}{\leq}\,#1}
\newcommand{\tfmap}{\mathsf{fmap}}
\newcommand{\fmap}[2][]{\tfmap_{#1}\,#2}
\newcommand{\fmapt}[2][]{\tfmap_{#1}#2}
\newcommand{\treturn}{\mathsf{return}}
\newcommand{\tjoin}{\mathsf{join}}
\newcommand{\join}{\mathsf{join}}
\newcommand{\append}{\ensuremath{\mathbin{\mathtt{++}}}}
\newcommand{\tcast}{\mathsf{cast}}
\newcommand{\tdist}{\mathsf{dist}}
\newcommand{\Id}{\mathsf{Id}}
\newcommand{\tid}[1][]{\mathsf{id}_{#1}}
\newcommand{\teval}{\mathsf{eval}}
\newcommand{\tstrength}{\mathsf{strength}}
\newcommand{\strengthl}{\tstrength^{\tl}}
\newcommand{\strengthr}{\tstrength^{\tr}}
\newcommand{\tl}{\mathsf{l}}
\newcommand{\tr}{\mathsf{r}}
\newcommand{\tcurry}{\mathsf{curry}}
\newcommand{\comp}{\circ}
\newcommand{\tweaken}{\mathsf{weaken}}
\newcommand{\tdrop}[1][]{\mathsf{drop}_{#1}}
%\newcommand{\drop}[1][]{\tdrop_{#1}} % Name clash
\newcommand{\tcontract}{\mathsf{contract}}
\newcommand{\contract}[1][]{\tcontract_{#1}}

% Types
\newcommand{\tTy}{\mathsf{Ty}}
\newcommand{\Ty}[1]{\tTy^{#1}}
\newcommand{\PTy}{\Ty+}
\newcommand{\NTy}{\Ty-}
\newcommand{\Cxt}{\mathsf{Cxt}}
\newcommand{\RCxt}{\mathsf{RCxt}}
\newcommand{\cempty}{\emptyset}
\newcommand{\extr}[2]{#1.#2}
\newcommand{\ext}[3]{#1.#2{:}#3}
\newcommand{\qext}[5]{#1#2.#3#4{:}#5}
\newcommand{\gqext}[5]{\graybox{#1}#2.\graybox{#3}#4{:}#5}


\newcommand{\sumt}   [2]{\ensuremath{\Sigma_{#1} #2}}
\newcommand{\tupt}   [2]{\ensuremath{\mathop\otimes_{#1} #2}}
\newcommand{\rect}   [2]{\ensuremath{\Pi_{#1} #2}}
\newcommand{\sumty}  [3]{\ensuremath{\Sigma_{#1:#2} #3_{#1}}}
\newcommand{\tupty}  [3]{\ensuremath{\mathop\otimes_{#1:#2} #3_{#1}}}
\newcommand{\recty}  [3]{\ensuremath{\Pi_{#1:#2} #3_{#1}}}
\newcommand{\thunkty}[2]{\ensuremath{[#1]#2}}
\newcommand{\compty} [2]{\ensuremath{\langle#1\rangle#2}}

% Terms
\newcommand{\tTm}{\mathsf{Tm}}
\newcommand{\Tm}[1]{\tTm^{#1}}
\newcommand{\PTm}{\Tm+}
\newcommand{\NTm}{\Tm-}
\newcommand{\tthunk}{\mathsf{thunk}}
\newcommand{\thunk}[1]{\tthunk\,#1}
\newcommand{\tforced}{\mathsf{forced}}
\newcommand{\tforce}{\mathsf{force}}
\newcommand{\force}[1]{\tforce\,#1}
\newcommand{\tin}[1]{\mathsf{in}_{#1}}
\newcommand{\inj}[2]{\tin{#1}\,#2}
\newcommand{\ttup}[1]{\mathsf{tup}^{#1}}
\newcommand{\tup}[2]{\ttup{#1}\,{#2}}
\newcommand{\ptup}[1]{\ttup\,{#1}}
% \newcommand{\ptup}[1]{\ttup{+}\,{#1}}
\newcommand{\ntup}[1]{\ttup{-}\,{#1}}
\newcommand{\tret}{\mathsf{ret}}
%\newcommand{\vlet}[3]{#1\,{=}\,#2;\,#3}
\newcommand{\ret}[1]{\tret\,#1}
\newcommand{\vlet}[3]{#2\,{\mathsf{be}}\,#1.\,#3}
% \newcommand{\let}[3]{#1\,{\leftarrow}\,#2;\,#3}
\newcommand{\bind}[3]{#2\,{\mathsf{to}}\,#1.\,#3}
% \newcommand{\bind}[3]{\ret #1\,{\leftarrow}\,#2;\,#3}
\newcommand{\tsplit}{\mathsf{split}}
\newcommand{\splits}[3]{#1\,{\tsplit}\,#2.\,#3}
\newcommand{\tcases}{\mathsf{cases}}
\newcommand{\case}[2]{#1\,{\tcases}\,\{#2\}}
\newcommand{\caser}[2]{#1\,{\tcases}\,#2}
\newcommand{\qlet}[4]{#3\,{\mathsf{be}}\,#1\,#2.\,#4}
\newcommand{\qbind}[4]{#3\,{\mathsf{to}}\,#1\,#2.\,#4}
\newcommand{\qsplits}[4]{#2\,{\tsplit}\,#1\,#3.\,#4}
\newcommand{\qforced}[4]{#2\,{\tforced}\,#1\,#3.\,#4}
\newcommand{\qcase}[3]{#2\,{\tcases}\,\{#1\,#3\}}
\newcommand{\gqlet}[4]{#3\,{\mathsf{be}}\,\graybox{#1}#2.\,#4}
\newcommand{\gqbind}[4]{#3\,{\mathsf{to}}\,\graybox{#1}#2.\,#4}
\newcommand{\gqsplits}[4]{#2\,{\tsplit}\,\graybox{#1}#3.\,#4}
\newcommand{\gqforced}[4]{#2\,{\tforced}\,\graybox{#1}#3.\,#4}
\newcommand{\gqcase}[3]{#2\,{\tcases}\,\{\graybox{#1}#3\}}
% \newcommand{\qlet}[4]{#1\,#3\,{\mathsf{be}}\,#2.\,#4}
% \newcommand{\qbind}[4]{#1\,#3\,{\mathsf{to}}\,#2.\,#4}
% \newcommand{\qsplits}[4]{#1\,#2\,{\tsplit}\,#3.\,#4}
% \newcommand{\qforced}[4]{#1\,#2\,{\tforced}\,#3.\,#4}
% \newcommand{\qcase}[3]{#1\,#2\,{\tcases}\,\{#3\}}
% \newcommand{\qcaser}[3]{#1\,#2\,{\tcases}\,#3}
% \newcommand{\gqlet}[4]{\graybox{#1}\,#3\,{\mathsf{be}}\,#2.\,#4}
% \newcommand{\gqbind}[4]{\graybox{#1}\,#3\,{\mathsf{to}}\,#2.\,#4}
% \newcommand{\gqsplits}[4]{\graybox{#1}\,#2\,{\tsplit}\,#3.\,#4}
% \newcommand{\gqforced}[4]{\graybox{#1}\,#2\,{\tforced}\,#3.\,#4}
% \newcommand{\gqcase}[3]{\graybox{#1}\,#2\,{\tcases}\,\{#3\}}
% \newcommand{\gqcaser}[3]{\graybox{#1}\,#2\,{\tcases}\,#3}
% \newcommand{\split}[3]{\ptup #1\,{\leftarrow}\,#2;\,#3}
\newcommand{\lam}[2]{\lambda#1.\,#2}
\newcommand{\app}[2]{#1\,#2}
\newcommand{\trecord}{\mathsf{record}}
\newcommand{\recrd}[2]{\trecord_{#1}\,#2}
\newcommand{\record}[2]{\trecord_{#1}\{#2\}}
\newcommand{\tproj}{\mathsf{proj}}
\newcommand{\proj}[2]{\tproj_{#1}\,{#2}}

% Judgements
\newcommand{\ValTy}[3]{#1 \vdash #2 : #3}
\newcommand{\oCompTy}{\ValTy}
\newcommand{\CompTy}[4]{#1 \vdash #2 : #4 \mid #3}
\newcommand{\gpValTy}[4]{\graybox{(#1)}#2 \vdash #3 : #4}
\newcommand{\gqValTy}[4]{\graybox{#1}#2 \vdash #3 : #4}
\newcommand{\gpCompTy}[4]{\graybox{(#1)}#2 \vdash #3 : #4}
\newcommand{\gqCompTy}[4]{\graybox{#1}#2 \vdash #3 : #4}
\newcommand{\pValTy}[4]{(#1)#2 \vdash #3 : #4}
\newcommand{\qValTy}[4]{#1#2 \vdash #3 : #4}
\newcommand{\pCompTy}[4]{(#1)#2 \vdash #3 : #4}
\newcommand{\qCompTy}[4]{#1#2 \vdash #3 : #4}
%\newcommand{\CompTy}[4]{#1 \vdash #2 \mathrel{{:}\langle #3 \rangle} #4}
\newcommand{\ru}{\dfrac}
\newcommand{\nru}[3]{#1\;\dfrac{#2}{#3}}
\newcommand{\nrux}[4]{#1\;\dfrac{#2}{#3}\;#4}

\newcommand{\rulename}[1]{\ensuremath{\mbox{\textsc{#1}}}\xspace}
\newcommand{\rintro}[1]{\ensuremath{\mathord{#1}\mbox{-\rulename{intro}}}\xspace}
\newcommand{\relim}[1]{\ensuremath{\mathord{#1}\mbox{-\rulename{elim}}}\xspace}
\newcommand{\rvar}{\rulename{var}}
\newcommand{\rlet}{\rulename{let}}
\newcommand{\rsub}{\rulename{sub}}
\newcommand{\rweak}{\rulename{weak}}

% As effect algebra, we assume a pre-ordered monoid
% $(\Eff,\bu,\Ge,\leq)$ such that $\_{\bu}\_$ is monotone wrt.\ the
% preorder $\leq$ in both arguments.  The unit $\Ge$ shall mean \emph{no
%   effect} and the operation $\_{\bu}\_$ serves to accumulate effects,
% possibly in a sequential order---unless the monoid is commutative.  The
% preorder represents effect subsumption, i.e., loss in precision of the
% effect analysis.  Note that the unit $\Ge$ is not necessarily the least element
% wrt.\ $\leq$.

\subsection{Recapitulation: modelling effects via monads}
\label{sec:ccc}

Consider a categorical model $\CC$ of the simply-typed lambda calculus
(STLC), i.e., where types $\tau$ and contexts $\GG$ are interpreted as
objects $\den \tau$ and $\den \Gamma$ of $\CC$ and terms
$\GG \vdash t : \tau$ as morphisms $\dent t \in \CC(\den\GG,\den\tau)$.
Such a category could be $\SET$, interpreting types as sets and terms
as functions, mapping the valuation of their free variables to their
value, or $\CPO$, interpreting types as complete partial orders and
terms as monotone functions, or a presheaf model of the STLC etc.
Typically, $\CC$ is a cartesian-closed category, i.e., has products
$A_1 \times A_2$ of objects modelling product types and contexts,
and exponentials $A \To
B$ modeling function types.  Further $\CC$ maybe be distributive,
\ie, have coproducts $A_1 + A_2$ that distribute over products, to
model variants aka disjoint sum types.

Recall that effects are modeled by a suitable monad $\T$ in
$\CC$.  An example would be the \emph{writer monad} $\T\,A = \String \times
A$ that models the effect \emph{output}.
Another example would be the \emph{exception monad} $\Exc + \_$ where
the result of a computation is either an exception $e : \Exc$ or a
regular result.
The monad operations, together with
their implementation for \emph{writer} in $\SET$, are the following:
\[
\begin{array}{lcl}
\tfmap & : & (A \to B) \to \T\,A \to \T\,B \\
\tfmap\, f\, (s,\; a) & = & (s,\, f\, b)
\\[1ex]
\treturn & : & A \to \T\,A \\
\treturn\, a & = & (\verb|""|, a)
\\[1ex]
\tjoin & : & \T\,(\T\,A) \to \T\,A \\
\tjoin\,(s_1,(s_2,a)) & = & (s_1 \append s_2,\; a) \\
\end{array}
\]
Herein, \verb|""| shall denote the empty string and $\append$ string
concatenation.

We assume familiarity with the functor laws $\tfmap\,\tid = \tid$ and
$\tfmap\,(f \circ g) = \tfmap\,f \circ \tfmap\,g$.
The three equational
laws of $\tjoin$ can be visualized compactly in the following
commutative diagram.
\[
\xymatrix@C=12ex{
  \T\,A     \ar[r]^{\treturn} \ar@{=}[dr]^{\tid}
& \T\,(\T\,A) \ar[d]^{\tjoin}
& \T\,(\T\,(\T\,A)) \ar[l]_{\tjoin} \ar[d]^{\tfmap\,\tjoin}
\\
& \T\,A       \ar@{=}[dr]^{\tid}
& \T\,(\T\,A) \ar[l]_{\tjoin}
\\
&
& \T\,A \ar[u]_{\tfmap\,\treturn}
}
\]

\subsection{Effect algebras and graded monads}
\label{sec:graded_monad}

Following \citet{katsumata:popl14}
we can obtain more information about effects using a monad $\T[e]$
\emph{graded} over elements $e$ of a suitable effect algebra $\Eff$.
An effect algebra be a pre-ordered monoid
$(\Eff,\bu,\Ge,\leq)$ such that $\_{\bu}\_$ is monotone wrt.\ the
preorder $\leq$ in both arguments.  The unit $\Ge$ shall mean \emph{no
  effect} and the operation $\_{\bu}\_$ serves to accumulate effects,
possibly in a sequential order---unless the monoid is commutative.  The
preorder represents effect subsumption, i.e., loss in precision of the
effect analysis.  Note that the unit $\Ge$ is not necessarily the least element
wrt.\ $\leq$.

Say we want to track an upper bound on the length of the output
produced by a program.  To this end, we can use the preordered monoid
$\Eff = \bN \cup \{\infty\}$ under addition $\_{\bu}\_ = \_{+}\_$
with unit $\Ge = 0$ and the
natural order $\leq$.  The effect $\infty$ then denotes unbounded output, or
output whose length we cannot track in the type system (\eg, when it
depends on some variable).  Increasing the upper bound along $\leq$
means loss of precision of our analysis, with $\infty$ the least
precise information, meaning no upper bound.  The corresponding graded
writer monad is $\T[e]\,A = (\StringLe e) \times A$ where the output is an
element of $\StringLe e$, a string of length at most $e \in \bN \cup
\{\infty\}$.  The operations of a graded monad are, again given with
their $\SET$-implementation for the graded writer:
\[
\begin{array}{lcl}
\tfmap & : & (A \to B) \to \T[e]\,A \to \T[e]\,B \\
\tfmap\, f\, (s,\; a) & = & (s,\, f\, b)
\\[1ex]
\treturn & : & A \to \T[\Ge]\,A \\
\treturn\, a & = & (\verb|""|, a)
\\[1ex]
\tjoin & : & \T[e_1]\,(\T[e_2]\,A) \to \T[e_1 \bu e_2]\,A \\
\tjoin\,(s_1,(s_2,a)) & = & (s_1 \append s_2,\; a)
\\[1ex]
\tcast & : & \T[e] \to \T[e'] \mbox{ for } e \leq e'\\
\tcast & = & \tid \\
\end{array}
\]
A graded version of the exception monad would use effect algebra
$\Eff = \Pot\Exc$ under union and subset; an effect $e$ is a set of
possible exceptions thrown by a computation.\footnote{An example of a
  exception-tracing type system is the Java language.}

The interesting laws for graded monads are given by the following
commutative diagrams.
\[
\xymatrix@C=8ex{
  \T[e]\,A     \ar[r]^{\treturn} \ar@{=}[dr]^{\tid}
& \T[\Ge]\,(\T[e]\,A) \ar[d]^{\tjoin}
\\
& \T[e]\,A
}
\quad
\xymatrix@C=10ex{
  \T[e]\,A     \ar[r]^{\tfmap\,\treturn} \ar@{=}[dr]^{\tid}
& \T[e]\,(\T[\Ge]\,A) \ar[d]^{\tjoin}
\\
& \T[e]\,A
}
\quad
\xymatrix@C=8ex{
  \T[e_1 \bu e_2]\,(\T[e_3]\,A) \ar[d]^{\tjoin}
& \T[e_1]\,(\T[e_2]\,(\T[e_3]\,A)) \ar[l]_{\tjoin} \ar[d]^{\tfmap\,\tjoin}
\\
  \T[e_1 \bu e_2 \bu e_3]\,A
& \T[e_1]\,(\T[e_2 \bu e_3]\,A) \ar[l]_{\tjoin}
}
\]
Further, $\tcast$ commutes with $\tfmap$, namely $\tfmap\,f \circ
\tcast = \tcast \circ \tfmap\,f$, and in two ways with $\tjoin$, namely
$\tjoin \circ \tcast = \tcast \circ \tjoin$ and $\tjoin
\circ \tfmap\,\tcast = \tcast \circ \tjoin$.

\subsection{CBPV, monad algebras, and their graded version}
\label{sec:graded_algebra}

Call-by-push value \cite{levy:hosc06} is a refinement of Moggi's
computational lambda-calculus \cite{moggi:infcomp91} that allows effects
not only in monadic types, \ie, in objects $\T\,A$, but more generally
in computation types.  These correspond to monad algebras for $\T$ in $\CC$,
aka $\T$-algebras.
Those are objects $B$ together with a morphism $\run[B] : \T\,B
\to B$ that allows to formally \emph{run} the monad, ``merging'' its
effects into $B$.
The prime example of a monad algebra is simply a monadic
type, because $\run[\T\,A] : \T\,(\T\,A) \to \T\,A$ is just
$\tjoin$.  Levy \citeyearpar{levy:hosc06} shows that monad algebras are
closed under products and exponentiation with arbitrary objects.  \Eg,
in $\SET$ we can define, for \emph{writer} algebras:
\[
\begin{array}{lcl}
%   \run[B_1 \times B_2] & : & \T\,(B_1 \times B_2) \to B_1 \times B_2 \\
%   \run[B_1 \times B_2]\, (s,(b_1,b_2)) & = & (\run[B_1] (s,b_1),\
%                                            \run[B_2] (s,b_2))
% \\[1ex]
  \run[B \times B'] & : & \T\,(B \times B') \to B \times B' \\
  \run[B \times B']\, (s,(b,b')) & = & (\run[B] (s,b),\
                                           \run[B'] (s,b'))
\\[1ex]
  \run[A \To B] & : & \T\,(A \To B) \to (A \To B) \\
  \run[A \To B]\, (s,f) & = & \lambda a.\; \run[B]\,(s,\,f\,a)
\\
\end{array}
\]
These definition implement \emph{lazy} effects that cannot be observed
at computation types such as $A \To B$, but only at value types; the
$\run[]$ of the monad algebra pushes the effects towards result types
that are eventually types of observable objects (values).

With $\run[]$ being a generalization of $\tjoin$, the laws for $\run[]$
are in analogy of those for $\tjoin$ (if $B$ were $\T\,A$):
\[
\xymatrix@C=10ex{
  B     \ar[r]^{\treturn} \ar@{=}[dr]^{\tid}
& \T\,B \ar[d]^{\run[]}
& \T\,(\T\,B) \ar[l]_{\tjoin} \ar[d]^{\tfmap\,\run[]}
\\
& B
& \T\,B \ar[l]_{\run[]}
}
\]

In graded CBPV, monad algebras get replaced by \emph{graded monad
  algebras}.  Given a graded monad $\T$, a $\T$-algebra is a family of
objects $\left(B_e\right)_{e:\Eff}$ and morphisms
$\run[B] : \T[e_1]\,B_{e_2} \to B_{e_1 \bu e_2}$ satisfying these
laws:
\[
\xymatrix@C=10ex{
  B_e     \ar[r]^{\treturn} \ar@{=}[dr]^{\tid}
& \T[\Ge]\,B_e \ar[d]^{\run[]}
\\
& B_e
}
\qquad
\xymatrix@C=10ex{
  \T[e_1 \bu e_2]\,B_{e_3} \ar[d]^{\run[]}
& \T[e_1]\,(\T[e_2]\,B_{e_3}) \ar[l]_{\tjoin} \ar[d]^{\tfmap\,\run[]}
\\
  B_{e_1 \bu e_2 \bu e_3}
& \T[e_1]\,B_{e_2 \bu e_3} \ar[l]_{\run[]}
}
\]
Further the family $B$ should be functorial in the sense that there is
a family of coercion morphisms $B_{e_1 \leq e_2} : B_{e_1} \to B_{e_2}$ with
$B_{e \leq e} = \tid$ and $B_{e_2 \leq e_3} \circ B_{e_1 \leq e_2} =
B_{e_1 \leq e_3}$.

Graded monad algebras are as well closed under
pointwise products $(B \times B')_e = B_e \times B'_e$ and
exponentiation with objects $(A \To B)_e = A \to B_e$;
here the graded writer example:
\[
\begin{array}{lcl}
  \run[B \times B'] & : & \T[e_1]\,(B \times B')_{e_2} \to (B \times
                          B')_{e_1 \bu e_2} \\
  \run[B \times B']\, (s,(b,b')) & = & (\run[B] (s,b),\
                                           \run[B'] (s,b'))
\\[1ex]
  \run[A \To B] & : & \T[e_1]\,(A \To B)_{e_2} \to (A \To B)_{e_1 \bu e_2} \\
  % \run[A \To B] & : & \T[e_1]\,(A \To B_{e_2}) \to (A \To B_{e_1 \bu e_2}) \\
  \run[A \To B]\, (s,f) & = & \lambda a.\; \run[B]\,(s,\,f\,a)
\\
\end{array}
\]

\begin{figure}[htbp]
\flushleft
\ruler{}
Types.
\[
\begin{array}{lllrl@{\qquad}l}
\PTy & \ni & P
  & ::= & \graybox{\thunkty e N}
     \mid o \mid \sumty i I P \mid \tupty i I P
  & \mbox{Value types (positive types)} \\
\NTy & \ni & N
  & ::= & \diamond P
     \mid P \To N \mid \recty i I N
  & \mbox{Computation types (negative types)} \\
\Cxt & \ni & \Gamma
  & ::= & \cempty \mid \ext \Gamma x P
  & \mbox{Typing context}
\\
\end{array}
\]
\dashruler{}
Terms.
\[
\begin{array}{lllrl@{\qquad}l}
\PTm & \ni & v,w
  & ::= & x
     \mid \thunk t
     \mid \inj i v
     \mid \ptup{\bar v}
  & \mbox{Values (positive terms)} \\
\NTm & \ni & t,u
  & ::= &
         \vlet x v t
  & \mbox{Computations (negative terms):}
\\ &&& \mid &
        \force v
    \mid \case v {\overline{x.\,t}}
    \mid \splits v {\bar x} t
  & \mbox{value eliminations}
\\ &&& \mid &
         \ret v        \mid \bind x u t
  & \mbox{monad operations}
\\ &&& \mid &
         \lam x t      \mid \app t v
  & \mbox{functions}
\\ &&& \mid &
         \trecord\{\overline{i:t}\} % \ntup{\bar t}
       \mid \proj i t
  & \mbox{lazy tuples (records)}
\end{array}
\]
\dashruler{}
Value typing \fbox{$\ValTy \Gamma v P$}\,.
\begin{gather*}
 \nru{\rvar}
     {x{:}P \in \Gamma
    }{\ValTy \Gamma x P}
\qquad
 \nru{\rintro\Box}
     {\CompTy \Gamma t {\graybox e} N
    }{\ValTy \Gamma {\thunk t} {\thunkty {\graybox e} N}}
\\[1.5ex]
 \nru{\rintro\GS}
     {\ValTy \Gamma v {P_i}
    }{\ValTy \Gamma {\inj i v} {\sumt I P}}
\qquad
 \nru{\rintro\otimes}
     {\forall i{:}I, \ \ValTy \Gamma {v_i} {P_i}
    }{\ValTy \Gamma {\ptup v} {\tupt I P}}
    % }{\ValTy \Gamma {\ptup{\overline{v_i}^{i:I}}} {\tupt I P}}
%    }{\ValTy \Gamma {\ptup (v_i)_{i:I}} {\tupt I P}}
\end{gather*}
\dashruler{}
Computation typing \fbox{$\CompTy \Gamma t {\graybox{e}} N$}\,.
\begin{gather*}
 \nru{\rlet}
     {\ValTy \Gamma v P \qquad
      \CompTy {\ext \Gamma x P} t e N
    }{\CompTy \Gamma {\vlet x v t} e N}
\qquad
 \nru{\relim\Box}
     {\ValTy \Gamma v {\thunkty {\graybox e} N}
    }{\CompTy \Gamma {\force v} {\graybox e} N}
\\[1.5ex]
 \nru{\relim\GS}
     {\ValTy \Gamma v {\sumt I P} \qquad
      \forall i{:}I,\ \CompTy {\ext \Gamma {x_i} {P_i}} {t_i} e N
    }{\CompTy \Gamma {\caser v {\{x_i.\, t_i\}_{i:I}}} e N}
\qquad
 \nru{\relim\otimes}
     {\ValTy \Gamma v {\tupt I P} \qquad
      \CompTy {\extr \Gamma {\overline{x_i{:}P_i}^{i:I}}} t e N
    }{\CompTy \Gamma {\splits v {\bar x} t} e N}
\\[1.5ex]
 \nru{\rintro\diamond}
     {\ValTy \Gamma v P
    }{\CompTy \Gamma {\ret v} {\graybox \Ge} {\diamond P}}
\qquad
 \nru{\relim\diamond}
     {\CompTy \Gamma u {\graybox{e_1}} {\diamond P} \qquad
      \CompTy {\ext \Gamma x P} t {\graybox{e_2}} N
    }{\CompTy \Gamma {\bind x u t} {\graybox{e_1 \bu e_2}} N}
\\[1.5ex]
 \nru{\rintro\To}
     {\CompTy {\ext \Gamma x P} t e N
    }{\CompTy \Gamma {\lam x t} e {P \To N}}
\qquad
 \nru{\relim\To}
     {\CompTy \Gamma t e {P \To N} \qquad
      \ValTy \Gamma v P
    }{\CompTy \Gamma {\app t v} e N}
\\[1.5ex]
 \nru{\rintro\Pi}
     {\forall i{:}I,\ \CompTy \Gamma {t_i} e {N_i}
    }{\CompTy \Gamma {\trecord {\{i : t_i\}_{i:I}}} e {\rect I N}}
    % }{\CompTy \Gamma {\ntup{\overline{t_i}^{i:I}}} e {\rect I N}}
\qquad
 \nru{\relim\Pi}
     {\CompTy \Gamma t e {\rect I N}
    }{\CompTy \Gamma {\proj i t} e  {N_i}}
\\[1.5ex]
\graybox{
 \nrux{\rsub}
      {\CompTy \Gamma t e N}
      {\CompTy \Gamma t {e'} N}
      {e \leq e'}
}
\end{gather*}
\rule{\textwidth}{0.2pt}
  \caption{Effect-graded call-by-push-value.}
  \label{fig:cbpv}
\end{figure}

\subsection{Effect-graded CBPV: syntax and typing}
\label{sec:effect-cbpv}

The syntax and typing rules for effect-graded CBPV are given in
Fig.~\ref{fig:cbpv}.  The differences to pure CBPV are in
\graybox{\mbox{gray boxes}}.

Types are classified into value types $P \in \PTy$ (written $A$ in
\citet{levy:hosc06}) and computation types $N \in \NTy$
(written $\underline B$ in
\loccit).  These are positive and negative types in the terminology of
focusing \cite{zeilberger:PhD}.
Positive types are generated from base types $o$ via
disjoint sums $\sumty i I P$ with tag set $I$, eager products $\tupty
i I P$ of arity $I$ (composed
from $1$ and $A_1 \times A_2$ in \loccit) and thunking $\thunkty e N$
(written $U\,\underline B$ in \loccit).  In contrast to pure CBPV,
thunk types $\thunkty e N$ are annotated with an effect $e$ that can
be triggered when the thunk is forced.  Negative types are just as in
pure CBPV: monadic types $\diamond P$ (written $F\,A$ in \loccit),
function types $P \To N$ (written $A \to \underline B$) in \loccit)
and record types $\recty i I N$ with label set $I$.
Records are \emph{lazy} tuples whose components are only computed by demand.
We abbreviate $\sumty i I P$ by its ``meta-level $\eta$-contraction''
$\sumt I P$; notations $\tupt I P$ and
$\rect I N$ are understood analogously.

Terms are separated into values $v \in \PTm$ and computations $t \in
\NTm$ and identical to pure CBPV, modulo changes in the concrete
syntax.  Values introduce positive types,
computations introduce
negative types and
eliminate both positive and negative types.
We use bars to indicate sequences, e.g., $\bar v$ for a
sequence of values, but drop the bar when the context of discourse
makes clear that we are dealing with sequences rather than single
objects.  For instance, ``$v_i$'' (where $i : I$) in the premise of
\rintro\otimes indicates that $v$ is a sequence of values with
elements $(v_i)_{i:I}$.  We may abbreviate $\trecord \{i :
t_i\}_{i:I}$ by $\recrd I t$ where $I$ is the label set and $t$ a
mapping from labels $i:I$ to terms $t_i$.

The meaning of the term constructors is best understood via their
typing.  Typing contexts $\Gamma$ are finite maps from variables $x$
to value types $P$, with $\ext \Gamma x P$ denoting the update of the
finite map $\Gamma$ at key $x$ with value $P$.

Value typing $\ValTy \Gamma v P$ is just as in pure CBPV, however,
computation typing $\CompTy \Gamma t e N$ also records effects $e :
\Eff$ potentially produced at runtime by computation $t$.  Thunking a
computation (rule \rintro\Box) stores the inferred effect classifier
$e$ in the thunk type $\thunkty e N$.

Effects are accumulated via the introduction and elimination rule for
the graded monad.  The unit $\ret v$ of the monad is effect-free
(\rintro\diamond), running this computation just produces the pure
value $v$.  Sequencing computations $u$ and $t$ via the \emph{bind}
construct $\bind x u t$ composes the effects $e_1$ of $u$ with the
effects $e_2$ of $t$ in that order.  The intuition is that first $u$
is run, producing effects classified by $e_1$, and its result is bound
to $x$ to run $t$, producing effects classified by $e_2$.  The sum of
the effects is classified by $e_1 \bu e_2$.

The other introduction and elimination rules are just as in pure
CBPV, except that they propagate the effect classifier $e$ from
hypothesis to conclusion.  Note that in case distinction (\relim\GS)
and record construction (\rintro\Pi) all subterms $t_i$ are required
to produce effects classified by the same $e$.  However, in reality,
different branches of a case distinction, for instance, may produce
very different effects.  To end up with a unique classifier $e$, the
branches may have to be typed using effect subsumption (\rsub).  In
fact, the uses of \rsub can be confined to the hypotheses of \relim\GS
and \rintro\Pi, except for a final invokation of \rsub at the very end
of the typing derivation.  Alternatively, we could have introduced
effect algebras with suprema $\sup_{i:I} e_i$ instead of a preorder $e
\leq e'$.  However, suprema might not always exist; by using
subsumption \rsub, we delegate the problem of partiality to the
construction of a typing derivation.

\begin{remark}\label{rem:cbpv}
  We recover pure CBPV from graded CBPV using the trivial effect
  algebra $\Eff = \{\Ge\}$.
\end{remark}

\subsection{Effect graded CBPV: denotational semantics}

The denotational semantics of graded CBPV has been informally explained in
sections \ref{sec:ccc} to \ref{sec:graded_algebra} already; in the following,
we spell out the details.  We assume a distributive cartesian-closed
category $\CC$ with a strong graded monad $\T : \Eff \to \CC \to \CC$.
Let us agree on some notation for the constructions on objects and
morphisms:
\begin{itemize}
\item Product $\prod_{i:I} A_i$ with projections $\pi_i : \CC(\prod_I
  A, A_i)$ and tupling $\langle f_i
  \rangle_{i:I} : \CC(C,\prod_i A)$ for $f_i : \CC(C,A_i)$.  Binary
  products $\prod_{\{1,2\}} A$ are written $A_1 \times A_2$.
\item Coproduct $\coprod_{i:I} A_i$ with injections $\iota_i :
  \CC(A_i,\coprod_I A)$ and cotupling $[f_i]_{i:I} : \CC(\coprod_I A,
  B)$ for $f_i : \CC(A_i,B)$.
\item Exponential $A \To B$ with $\Lambda : \CC(C \times A, B) \to
  \CC(C, A \To B)$ and $\teval : \CC((A \To B) \times A, B)$.
\item Graded monad $\T$ with functoriality $\fmap[\T] f :
  \CC(\T[e]A,\T[e]B)$ for $f : \CC(A,B)$,
  unit $\treturn : \CC(A,\T[\Ge]A)$,
  multiplication $\tjoin : \CC(\T[e_1](\T[e_2]A),\T[e_1 \bu e_2]A)$,
  strength $\strengthl : \CC(A \times \T[e]B, \T[e](A \times B))$ and
  coercion $\tcast : \CC(\T[e]A,\T[e']A)$ for $e \leq e'$.
  Costrength $\strengthr : \CC(\T[e]A \times B, \T[e](A \times B))$
  is derivable in the standard way.
\end{itemize}

\subsubsection{Interpretation of types}

Positive types $P$ are interpreted as objects $\denp P$ of $\CC$,
where a denotation $\denp o : \CC$ of base types $o$ is assumed.
This interpretation lifts to contexts $\Gamma$ via $\denp \Gamma =
\prod_{x:\dom(\Gamma)} \denp{\Gamma(x)}$.

Negative types $N$ are interpreted
as functors $\denn N : (\Eff,\leq) \to \CC$ mapping
effect classifiers $e$ to objects $\Denn N e$ and effect subsumption $e
\leq e'$ to morphisms $\Denn N {e \leq e'} : \Denn N e \to \Denn N {e'}$.
\[
\begin{array}{lcl}
  \denp\_ & : & \PTy \to \CC \\
  \denp{\thunkty e N} & = & \Denn N e \\
  \denp{\sumt I P} & = & \coprod_{i:I} \denp{P_i} \\
  \denp{\tupt I P} & = & \prod_{i:I} \denp{P_i} \\
\end{array}
\qquad\qquad
\begin{array}{lcl}
  \Denn\_\_ & : & \NTy \to \Eff \to \CC \\
  \Denn{\diamond P} e & = & \T[e] \denp P \\
  \Denn{P \To N}   e & = & \denp P \To \Denn N e \\
  \Denn{\rect I N} e & = & \prod_{i:I} \Denn{N_i}e \\
  % \denn{P \To N}   e & = & \denp P \To (\denn N e) \\
  % \denn{\rect I N} e & = & \prod_{i:I} \left(\denn{N_i}e\right) \\
\end{array}
\]
The graded $\T$-algebra structure $\run{\denn N}$ is constructed by
induction on $N$:
\[
\begin{array}{lcl}
  \run{\denn N} & : & \Hom {\T[e_1](\Denn N {e_2})} {\Denn N {e_1 \bu e_2}} \\
  \run{\denn {\diamond P}} & = & \tjoin \\
  \run{\denn {P \To N}}   & = & \Lambda(\run{\denn N} \circ
                                \fmap[\T]\teval \circ \strengthr) \\
  \run{\denn {\rect I N}} & = & \langle \run{\denn{N_i}} \comp
                                \fmap[\T]{\pi_i} \rangle_{i:I} \\
\end{array}
\]
This construction is the same as \citet{levy:hosc06}, modulo grading.
The algebra laws ensue.

The coercion morphisms $\Denn N {e_1 \leq e_2}$ are obtained
analogously:
\[
\begin{array}{rcl}
  \Denn N {e_1 \leq e_2} & : & \Hom {\Denn N {e_1}} {\Denn N {e_2}} \\
  \Denn {\diamond P} {e_1 \leq e_2} & = & \tcast \\
  \Denn {P \To N}   {e_1 \leq e_2} & = &
    \Lambda(\Denn N {e_1 \leq e_2} \comp \teval) \\
  \Denn {\rect I N} {e_1 \leq e_2} & = &
    \langle \Denn N {e_1 \leq e_2} \comp \pi_i {} \rangle_{i:I} \\
\end{array}
\]
That these coercions satify the identity and composition---the functor
laws for $\denn N$---is easy to verify.

\subsubsection{Interpretation of terms}

Values $\ValTy \Gamma v P$ are interpreted as morphisms $\dent v :
\Hom {\denp \Gamma} {\denp P}$ just as in pure CBPV.  Computations
$\CompTy \Gamma t e N$ are interpreted as morphisms $\dent t : \Hom
{\denp \Gamma} {\Denn N e}$.  Most of the cases are straightforward
and in analogy to CBPV, let us thus focus on the
\graybox{\mbox{modified}} rules where grading comes into play.  A
subtlety is that we interpret \emph{typing derivations} rather than terms,
because rule \rsub is a silent construction on raw terms but becomes a
coercion in the denotational semantics.  The most natural way to make
this precise is to use intrinsically well-typed syntax; from typing
rules to such well-typed syntax is a routine transformation which we
do not spell out here.  The reader interested in well-typed syntax for
CBPV is referred to \citet{abelSattler:ppdp19}.
The other subtlety, that we ignore variable names in the
interpretation, can also be made precise by well-typed syntax which
uses de Bruijn indices.

As in Levy's algebra semantics \citeyearpar{levy:hosc06}, creation and
forcing of thunks is invisible in the model.  The bind operation
(\relim\diamond) utilizes the generalization of $\tjoin$ to $\trun$.
Subsumption is interpreted by functoriality in $\Eff$.
\[
\begin{array}{llcl}
\rintro\Box & \dent{\thunk t} & = & \dent t \\
\relim\Box  & \dent{\force v} & = & \dent v
\\[1ex]
\rintro\diamond & \dent{\ret v} & = & \treturn \comp \dent v \\
\relim\diamond  & \dent{\bind x u t} & = &
  \run{\denn N} \comp \fmap[\T]\teval \comp \strengthl \comp
  \langle \Lambda\dent t,\,\dent u \rangle
\\[1ex]
\rsub & \dent t & = & \Denn N {e \leq e'} \comp \dent t
\\
\end{array}
\]
These definitions are understood in the context of the given typing rules.

\subsection{Grading via a partial monoid}

Not all sequences of effects are always meaningful: For instance,
reading from a file before it was opened is impossible and could be
prevented statically by graded effect typing.  This could be modelled
by adding a maximal element $\top : \Eff$---with $e \leq top$ for all
$e : \Eff$ that signifies an inconsistent state.  This error element
would also be dominant in sequences, \ie,
$\top \bu e = e \bu \top = \top$.
A program $\CompTy \Gamma t e N$ would only be accepted if $e \not= \top$.

Alternatively, we could work with a partial monoid, \ie, a carrier $\Eff$ with a predicate $\Ge{\leq}\_$ and a ternary relation $\_{\bu}\_{\leq}\_$ such that
the following laws hold:
\begin{enumerate}
\item Unit: $e \leq e' \defiff \exists e_0.\, \Ge \leq e_0 \land e_0 \bu e \leq e'$ iff $\exists e_0.\, \Ge \leq e_0 \land e \bu e_0 \leq e'$.
% \item Unit: $e \leq e' \defiff (\exists e_0.\, \Ge \leq e_0 \land e_0 \bu e \leq e')$ iff $(\exists e_0.\, \Ge \leq e_0 \land e \bu e_0 \leq e')$.
\item Associativity: $\exists e_{12}.\ e_1 \bu e_2 \leq e_{12} \land e_{12} \bu e_3 \leq e_{123}$ iff $\exists e_{23}.\ e_1 \bu e_{23} \leq e_{123} \land e_2 \bu e_3 \leq e_{23}$.
\item Monotonicity of $\Ge{\leq}\_$: If $\Ge \leq e$ and $e \leq e'$ then $\Ge \leq e'$.
\item Monotonicity of $\_{\bu}\_{\leq}\_$:  If $e_1' \leq e_1$ and $e_2' \leq e_2$ and $e \leq e'$ and $e_1 \bu e_2 \leq e$ then $e_1' \bu e_2' \leq e'$.
\item Reflexivity and transitivity of $\leq$.
\end{enumerate}
The typing rules for $\diamond$ would change accordingly.
\begin{gather*}
 \nrux{\rintro\diamond}
     {\ValTy \Gamma v P
    }{\CompTy \Gamma {\ret v} e {\diamond P}
    }{\graybox{\Ge \leq e}}
\qquad
 \nrux{\relim\diamond}
     {\CompTy \Gamma u {e_1} {\diamond P} \qquad
      \CompTy {\ext \Gamma x P} t {e_2} N
    }{\CompTy \Gamma {\bind x u t} e N
    }{\graybox{e_1 \bu e_2 \leq e}}
\end{gather*}
Rule $\rsub$ would be admissible.

A monad $\T : \Eff \to [\CC \to \CC]$ graded by a partial monoid
$\Eff$ has natural transformations $\Id \todot \T[e]$ for $\Ge \leq e$
and $\T[e_1] \circ \T[e_2] \todot \T[e]$ for $e_1 \bu e_2 \leq e$.  A
$\T$-algebra $B$ has morphism $\run[B] : \T[e_1]B_{e_2} \to B_{e}$
for $e_1 \bu e_2 \leq e$.



\section{Coeffect-graded CBPV}
\label{sec:coeff}

\newcommand{\lolli}{\multimap}
\newcommand{\qfun}[3]{#1#2 \lolli #3}
\newcommand{\gqfun}[3]{\graybox{#1#2 \lolli #3}}
\renewcommand{\CompTy}[3]{#1 \vdash #2 : #3}
\newcommand{\nbox}[1]{}
\newcommand{\tzip}{\mathsf{zip}}
\newcommand{\textract}{\mathsf{extract}}
\newcommand{\extract}[1][]{\textract_{#1}}
\newcommand{\tdisplay}{\mathsf{display}}
\newcommand{\display}[1][]{\tdisplay_{#1}}
% \newcommand{\tduplicate}{\mathsf{display}}
% \newcommand{\duplicate}[1][]{\tdisplay_{#1}}
\newcommand{\tduplicate}{\mathsf{duplicate}}
\newcommand{\duplicate}[1][]{\tduplicate_{#1}}
\newcommand{\tcobind}{\mathsf{cobind}}
\newcommand{\tbind}{\mathsf{bind}}
\newcommand{\tget}{\mathsf{get}}
\newcommand{\tmodify}{\mathsf{modify}}
\newcommand{\thead}{\mathsf{head}}
\newcommand{\ttail}{\mathsf{tail}}
\newcommand{\suc}{(\_{+}1)}
\newcommand{\Float}{\mathsf{Float}}
\newcommand{\tiso}{\mathsf{iso}}
\newcommand{\isot}{\tiso^\otimes}

CBPV places the monad $\diamond P$ at the transition from positive
types to negative types.  Dually, the transition $\Box N$ from
negative types to positive types is a vessel that can be filled with a
comonad.  Just like negative types $N$ are monad algebras, positive
types $P$ can be \emph{comonad coalgebras}.

\subsection{Comonadic CBPV and their comonad coalgebras}

% Let us consider the \emph{context comonad} $\D\,B = S \times B$ that
% gives us access to a value in $S$.
% \footnote{\url{https://bartoszmilewski.com/2017/01/02/comonads/}}
% Besides functoriality, a comonad
% has the natural transformations $\textract$ and $\display$, dual to
% $\treturn$ and $\tjoin$.  The implementation of the context comonad is
% as follows:
% \[
% \begin{array}{lcl}
%   \textract & : & \D\,B \to B \\
%   \textract\,(s,b) & = & b
% \\[1.5ex]
%   \tdisplay & : & \D,\B \to \D\,(\D\,B) \\
%   \tdisplay\,(s,b) & = & (s, (s, b))
% \\[1.5ex]
%   \tget & : & \D\,B \to S \\
%   \tget\,(s,b) & = & s
% \\[1.5ex]
%   \tmodify
% \end{array}
% \]
% The context comonad is not monoidal.

Let us consider the \emph{stream comonad}%
\footnote{\url{https://bartoszmilewski.com/2017/01/02/comonads/}}
$\D\,B = \bN \to B$,
with $\thead\,s = s\,0$ and $\ttail\,s = s \comp \suc$.
The stream comonad lets us work in a setting where values are not
single data points, but streams of data.
Besides functoriality, a
comonad has the natural transformations $\textract$ and $\display$
(in category theory called $\Ge$ and $\Gd$),
dual to $\treturn$ and $\tjoin$.  The implementation of the stream
comonad in $\SET$ is as follows:
\[
\begin{array}{lcl}
  \textract & : & \D\,B \to B \\
  \textract\,s & = & \thead\,s
\\[1.5ex]
  \tdisplay & : & \D\,B \to \D\,(\D\,B) \\
  \thead\,(\tdisplay\,s) & = & s \\
  \ttail\,(\tdisplay\,s) & = & \tdisplay\,(\ttail\,s) \\
\end{array}
\]
The generic operations of a comonad allow us to \emph{extract} the
value wrapped in a comonadic structure and to \emph{display} another
layer of that structure.

The comonad laws are a simple dualization of the monad laws:
\[
\xymatrix@C=10ex{
\D\,B  \ar@{=}[dr]
  & \D\,(\D\,B) \ar[l]_{\textract} \ar[r]^{\tdisplay}
  & \D\,(\D\,(\D\,B))
\\
  & \D\,B \ar[u]_{\tdisplay} \ar[r]^{\tdisplay} \ar@{=}[dr]
  & \D\,(\D\,B) \ar[u]_{\tfmap\,\tdisplay} \ar[d]^{\tfmap\,\textract}
\\
  &
  & \D\,B
}
\]

A \emph{monoidal} comonad implements an morphism $\tzip$ that combines
a tuples of comonadic values into one comonadic tuple:
\[
\begin{array}{lcl}
  \tzip & : & \tupt {i:I} {(\D\,B_i)} \to \D(\tupt I B) \\
  \tzip\,(s_i)_{i:I}\,n & = & (s_i\,n)_{i:I} \\
\end{array}
\]
Many other comonads are monoidal,
like the store comonad $(S \To \_) \times S$,
though not all, \eg, the context comonad $S{\times}\_$.
In this article, we consider only monoidal comonads.

If type constructor $\Box$ is interpreted as a monoidal comonad $\D$,
then all positive types $P$ can be intepreted as $\D$-coalgebras
$A = \den P$, \ie, implement a morphism $\expose[A] : A \to \D\,A$
satisfying the laws of a comonad coalgebra:
\[
\xymatrix@C=10ex{
A  \ar@{=}[dr]
  & \D\,A \ar[l]_{\textract} \ar[r]^{\tdisplay}
  & \D\,(\D\,A)
\\
  & A \ar[u]_{\texpose} \ar[r]^{\texpose}
  & \D\,A \ar[u]_{\tfmap\,\texpose}
}
\]
The implementation of $\expose[\den P]$ proceeds by induction on $P$.
\[
\begin{array}{lcl}
  \expose[\den{\Box N}] & : & {\D\,\den N} \to {\D\,(\D\,\den N)} \\
  \expose[\den{\Box N}] & = & \display
\\[1ex]
  \expose[\den{\tupt I P}] & : & \tupt {i:I} {\den{P_i}} \to \D\,(\tupt {i:I} {\den{P_i}}) \\
  \expose[\den{\tupt I P}] & = & \tzip \comp \tupt {i:I} \expose[\den{P_i}]
\\[1ex]
  \expose[\den{\sumt I P}] & : & \sumt {i:I} {\den{P_i}} \to \D\,(\sumt {i:I} {\den{P_i}}) \\
  \expose[\den{\sumt I P}] & = & \left[\tfmap\,\iota_i \comp \expose[\den{P_i}]\right]_{i:I} \\
\end{array}
\]
Positive base types $o \in \PTy$ are required to be $\D$-coalgebras.
For instance, elements of a base type like
$\Float \in \PTy$ could represent streams of floating point numbers,
\eg, continuous measurements from a sensor.

Because comonad coalgebras are closed under products for monoidal
coalgebras, contexts $\Gamma$ are interpreted as comonad coalgebras
$\den\Gamma$.  In the presence of a comonad interpretation of $\Box$,
the operations $\tthunk$ and $\tforce$ are no longer the identity, but
``generalized cobind'' and $\extract$:
\[
\begin{array}{lllcl}
 \rintro\Box
  & \ru{\oCompTy \Gamma t N
      }{\ValTy \Gamma {\thunk t} {\Box N}}
  & \dent{\thunk t} & = & \fmap[\D]{\dent t} \comp \expose[\den\Gamma]
\\[3ex]
 \relim\Box
  & \ru{\ValTy \Gamma v {\Box N}
      }{\oCompTy \Gamma {\force v} N}
  & \dent{\force v} & = & \textract \comp \dent v
\end{array}
\]
The map $\dent\tthunk : \Hom A B \to \Hom A {\D\,B}$ generalizes
$\tcobind : \Hom{\D\,A} B \to \Hom{\D\,A}{\D\,B}$ to $\D$-coalgebras
$A$ in the same way that the monadic
$\tbind : \Hom{A}{\T\,B} \to \Hom{\T\,A}{\T\,B}$ is generalized to
$\Hom{A}{B} \to \Hom{\T\,A}{B}$ for $\T$-algebras $B$ in CBPV.


% In a stream-valued instance of CBPV, elements of a base type like
% $\Float \in \PTy$ would represent streams of floating point numbers,
% \eg, continuous measurements from a sensor.
% However, a single comonad $\D$ may not sufficient to express what we
% want.  In the next section, we look at \emph{graded comonads}.

\subsection{Graded comonads and their coalgebras}

Graded comonads have been utilized to give semantics to
context-dependent computation \citep{orchard:icfp14}.  For grading,
loccit uses a \emph{resource algebra} in form of a pre-ordered
semiring
$(\R,{+},0,{\cdot},1,\leq)$.
% $(\R,\_{+}\_,0,\_{\cdot}\_,1,\leq)$.
%
The semantics is \emph{resource aware} and thus not constructed in a
cartesian-closed category but in a symmetric monoidal closed category
$(\CC,\otimes,\I,\lolli)$.  We overload the operators on
exponentials, $\Lambda : \Hom {C \otimes A} B \to \Hom C {A \lolli B}$
and $\teval : \Hom{(A \lolli B) \otimes A} B$.  The tensor product
$\otimes$ is a bifunctor and it is customary to overload $\otimes$ for
the functorial action
$f_1 \otimes f_2 : \Hom{A_1 \otimes A_2}{B_1 \otimes B_2}$ where
$f_i : \Hom{A_i}{B_i}$.  We shall also use $I$-ary products
$\tupt {i:I} {A_i}$ and their functorial action $\tupt {i:I} {f_i}$.
Further, the symmetric monoidal structure is usually witnessed by
isomorphisms for left $\lambda_A : \Hom {\I \otimes A} A$ and right
unit $\rho_A : \Hom {A \otimes I} A$, associativity
$\Ga_{A,B,C} : \Hom{A \otimes (B \otimes C)} {(A \otimes B) \otimes
  C}$
and swap $\sigma_{A,B} : \Hom {A \otimes B} {B \otimes A}$.  We shall
summarize combinations of these isomorphisms under the name
$\isot : \Hom {\tupt I A} {\tupt J B}$ when the multisets
$\{A_i\}_{i:I}$ and $\{B_j\}_{j:J}$ coincide modulo addition and
deletion of $\I$s.


As a running example for resource accounting,
we use the semiring $\R = \Pot\bN \setminus \emptyset$ of
\emph{multiplicities} ordered by $\supseteq$ with pointwise sum and
product, \eg, $r + s = \{ n + m \mid n \in r, m \in s \}$.
Subsemirings of $\R$ have been used for quantitative typing
\cite{sergeyVytiniotisPeytonJones:popl14,mcBride:wadler60,atkey:lics08}.
The order expresses precision of the quantities, \eg,
$\{1\} \geq \{0,1\} \geq \bN$ states that linear use of a variable is more informative than affine use than unrestricted use.

A matching symmetric monoidal closed category $\CC$ can be obtained as
follows:
% Assume a preordered commutative monoid $(\W,\oplus,\emp,\wleq,\winf)$
% that is also a $\winf$-semilattice with distribution law $\winf_{i:I} (w_i \oplus w'_i) \wleq \winf_I w \oplus \winf_I w'$.  The elements (``worlds'') can be
% seen as collection of available resources under uncertainty.  The
% order $w \wleq w'$ again expresses precision of information, \ie, if
% we can construct something from resources $w$ we can also construct it
% from $w'$.  The infimum $\winf_{i:I}w_i$ expresses we can build the
% ``thing'' from any of the $w_i$.  Multiplication $n \cdot w$ is
% understood as $w \oplus \dots \oplus w$ with $n$ summands.
% %
% Given a commutative monoid $(\M,\uplus,\emptyset)$ whose elements can
% be thought of as bags of atomic resources, an instance for $\W$ would
% be $\W = \Pot \M$ under ${\wleq} = {\subseteq}$ and pointwise union
% $w \oplus w' = \{ m \uplus m' \mid m \in w, m' \in w' \}$.
%
% Resource qualifiers $r \in \R$ operate on worlds via $r \cdot w = \winf_{n \in r} (n \cdot w)$.  It is routine to verify that $\W$ is almost a left semimodule to $\R$, \ie, the following laws hold:
% \[
% \begin{array}{rclclcl}
%   1 \cdot w
%     & = & \winf_{n \in \{1\}} nw
%     & = & 1w
%     & = & w
% \\
%   (rs) \cdot w
%     & = & \winf_{n \in r, m \in s} (nm)w
%     & = & \winf_{n \in r} n(\winf_{m \in s} mw)
%     & = & r \cdot (s \cdot w)
% \\
%   0 \cdot w
%     & = & \winf_{n \in \{0\}} nw
%     & = & 0w
%     & = & \emp
% \\
%   (r + s) \cdot w
%     & = & \winf_{n \in r, m \in s} (n+m)w
%     & = & \winf_{n \in r} \winf_{m \in s} (nw \oplus mw)
%     & = & (r \cdot w) \oplus (s \cdot w)
% \\
%   r \cdot \emp
%     & = & \winf_{n \in r} n\emp
%     & = & \winf_{n \in r} \emp
%     & = & \emp
% \\
%   r \cdot (w \oplus w')
%     & = & \winf_{n \in r} n(w \oplus w')
%     & \wleq & \winf_{n \in r} nw \oplus \winf_{n \in r} nw'
%     & = & (r \cdot w) \oplus (r \cdot w')
% \\
% \end{array}
% \]
Assume a preordered commutative monoid $(\W,\oplus,\emp,\wleq,\wsup)$
that is also a $\wsup$-semilattice with distribution law $\wsup_{i:I} (w_i \oplus w'_i) \wleq \wsup_I w \oplus \wsup_I w'$.  The elements (``worlds'') can be
seen as collection of available resources under choice.  The
order $w \wleq w'$ again expresses precision of information, \ie, if
we can construct something from resources $w$ we can also construct it
from $w'$ where we have additional choices.
The supremum $\wsup_{i:I}w_i$ expresses we can build the
``thing'' from any of the $w_i$.  Multiplication $n \cdot w$ is
understood as $w \oplus \dots \oplus w$ with $n$ summands.
%
Given a commutative monoid $(\M,\uplus,\emptyset)$ whose elements can
be thought of as bags of atomic resources, an instance for $\W$ would
be $\W = \Pot \M$ under ${\wleq} = {\subseteq}$ and pointwise union
$w \oplus w' = \{ m \uplus m' \mid m \in w, m' \in w' \}$.

Resource qualifiers $r \in \R$ operate on worlds via
$r \cdot w = \wsup_{n \in r} (n \cdot w)$.
%
For instance the \emph{affine} qualifier $\{0,1\}w = \emp \oplus w$
gives us the choice of using resources $w$ or not ($\emp$).
%
It is routine to verify that $\W$ is almost a left semimodule to $\R$,
\ie, the following laws hold:
\[
\begin{array}{rclclcl}
  1 \cdot w
    & = & \wsup_{n \in \{1\}} nw
    & = & 1w
    & = & w
\\
  (rs) \cdot w
    & = & \wsup_{n \in r, m \in s} (nm)w
    & = & \wsup_{n \in r} n(\wsup_{m \in s} mw)
    & = & r \cdot (s \cdot w)
\\
  0 \cdot w
    & = & \wsup_{n \in \{0\}} nw
    & = & 0w
    & = & \emp
\\
  (r + s) \cdot w
    & = & \wsup_{n \in r, m \in s} (n+m)w
    & = & \wsup_{n \in r} \wsup_{m \in s} (nw \oplus mw)
    & = & (r \cdot w) \oplus (s \cdot w)
\\
  r \cdot \emp
    & = & \wsup_{n \in r} n\emp
    & = & \wsup_{n \in r} \emp
    & = & \emp
\\
  r \cdot (w \oplus w')
    & = & \wsup_{n \in r} n(w \oplus w')
    & \wleq & \wsup_{n \in r} nw \oplus \wsup_{n \in r} nw'
    & = & (r \cdot w) \oplus (r \cdot w')
\\
\end{array}
\]
Because the last law is not an equality but just the inequality
$r (w \oplus w') \wleq rw \oplus rw'$, we have ``almost'' a
semimodule.

Objects of $\CC$ are functors $A : (\W,\wleq) \to \SET$ and morphisms
$f : \Hom A B$ are natural transformations
$(f_w : A_w \to B_w)_{w:W}$, \ie,
$B_{w \wleq w'} \comp f_w = f_{w'} \comp A_{w \wleq w'}$.  The tensor
$A \otimes B$ is Day's convolution
$(A \otimes B)_w = \bigcup_{w_1 \oplus w_2 \wleq w} (A_{w_1} \times B_{w_2})$
% $(A \otimes B)_w = \bigcup_{w_1,w_2 \mid w \geq w_1 \oplus w_2} A_{w_1} \times A_{w_2}$
with unit $\I_w = \bigcup_{\emp \wleq w} 1$.  The unit $\I$ is
constructible at world $w$ from nothing (set $1$) if $\emp \wleq w$,
\ie, if the world $w$ includes the choice of using no resources.  A
tensor $A \otimes B$ is constructible at world $w$ if $w$ includes the
choice to split the resources into $w_1$ and $w_2$ to construct $A$
and $B$, resp.  The exponential $A \lolli B$ is determined by currying
$C \otimes A \lolli B \cong C \lolli (A \lolli B)$ and given by
$(A \lolli B)_w = \bigcap_{w_1 \oplus w \wleq w_2} (A_{w_1} \to
B_{w_2})$.

The thus constructed symmetric monoidal closed category $\CC$ has a
$\R$-graded comonad
\[
\begin{array}{lcl}
  \D & : & (\R,\leq) \to [\CC \to \CC] \\
(\D[r] A)_w & = &
  \bigcup_{rw' \wleq w} A_{w'}
  % \bigcup_{w' \mid w \wleq rw'} A_{w'}
\end{array}
\]
implementing trivially the following natural transformations.  Herein, we use the
pointwise tensor product of functors
$(\dot\otimes_{i:I}F_i)\,A = \otimes_{i:I}(F_i\,A)$ in
$[\CC \to \CC]$, in particular $\dot\I\,A = \I$.
\[
\begin{array}{lcl@{~}c@{~}l}
  \textract   & : & \D[1]   & \todot & \Id \\
  \tdisplay & : & \D[rs]  & \todot & \D[r] \comp \D[s] \\
  \tdrop    & : & \D[0]   & \todot & \dot{\I} \\
  \tduplicate  & : & \D[r+s] & \todot & \D[r] \mathbin{\dot\otimes} \D[s] \\
  % \tdrop    & : & \Hom {\D[0]\,A} A \\
  % \tduplicate  & : & \Hom {\D[r+s]\,A} {\D[r]\,\A \otimes \D[s]\,A} \\
\end{array}
\]
For example, $\tduplicate$ takes
$a \in \bigcup_{rw' \oplus sw' \wleq w} A_{w'}$ to
$(a,a) \in \bigcup_{w_1 \oplus w_2 \wleq w} \bigcup_{rw_1' \leq w_1}
\bigcup_{sw_2' \leq w_2} A_{w'_1} \times A_{w'_2}$.
The intermediate worlds are $w_1' = w_2' = w'$ and $w_1 = rw'$ and $w_2 = sw'$.

The monoidal character of $\D$ is witnessed by the trivial morphism $\tzip$:
\[
%\newcommand{\Aiw}{(A_i)_{w'_i}}
\newcommand{\Aiw}{A_{iw'_i}}
\begin{array}{lcl}
  \tzip       & : & \Hom {\tupt {i:I} {(\D[r]\,A_i)}} {\D[r]\,(\tupt I A)} \\
  \tzip_w     & : & \bigcup_{\oplus_{i:I}w_i \wleq w} \Pi_{i:I} (\D[r]\,A_i)_{w_i} \to \bigcup_{rw' \wleq w} (\tupt I A)_{w'} \\
  \tzip_w     & : & \bigcup_{\oplus_{i:I} w_i \wleq w} \Pi_{i:I} (\bigcup_{rw'_i \wleq w_i} \Aiw) \to \bigcup_{rw' \wleq w} \bigcup_{\oplus_{i:I} w'_i \wleq w'} \Pi_{i:I} \Aiw \\
   \tzip_w\,(a_i)_{i:I} & = & (a_i)_{i:I} \\
\end{array}
\]

The comonad laws generalize to graded comonads as follows:
\[
\xymatrix@C=10ex{
\D[r]\,B  \ar[d]_{\tdisplay} \ar[r]^{\tdisplay} \ar@{=}[dr]
  & \D[r]\,(\D[1]\,B)  \ar[d]^{\tfmap\,\textract}
\\
\D[1]\,(\D[r]\,B) \ar[r]^{\textract}
  & \D[r]\,B
}
\qquad
\xymatrix@C=12ex{
\D[qrs]\,B \ar[d]_{\tdisplay} \ar[r]^{\tdisplay}
  & \D[qr]\,(\D[s]\,B) \ar[d]^{\tdisplay}
\\
\D[q]\,(\D[rs]\,B) \ar[r]^{\tfmap\,\tdisplay}
  & \D[q]\,(\D[r]\,(\D[s]\,B))
}
\]
% \[
% \xymatrix@C=10ex{
% \D[r]\,B  \ar@{=}[dr]
%   & \D[1]\,(\D[r]\,B) \ar[l]_{\textract}
% \\
%   & \D[r]\,B \ar[u]_{\tdisplay}
% }
% \qquad
% \xymatrix@C=10ex{
% \D[r]\,B  \ar[r]^{\tdisplay} \ar@{=}[dr]
%   & \D[r]\,(\D[1]\,B)  \ar[d]^{\tfmap\,\textract}
% \\
%   & \D[r]\,B
% }
% \]
% \[
% \xymatrix@C=10ex{
% \D[q]\,(\D[rs]\,B) \ar[r]^{\tdisplay}
%   & \D[q]\,(\D[r]\,(\D[s]\,B))
% \\
% \D[qrs]\,B \ar[u]_{\tdisplay} \ar[r]^{\tdisplay}
%   & \D[qr]\,(\D[s]\,B) \ar[u]_{\tfmap\,\tdisplay}
% }
% \]
These laws reflect that $\D$ maps the multiplicative monoid
$(\R,{\cdot},1)$ to the monoid structure $([\CC \to \CC],{\circ},\Id)$
of composition in the functor category $[\CC \to \CC]$.  Similar laws
need to hold for the additive monoid and distributivity.
\[
\xymatrix@C=12ex{
\D[0]\,B \otimes \D[r]\,B \ar[d]_{\tdrop \otimes \tid}
& \D[r]\,B \ar[l]_{\tduplicate} \ar[r]^{\tduplicate} \ar@{=}[d]
& \D[r]\,B \otimes \D[0]\,B \ar[d]^{\tid \otimes \tdrop}
\\
\I \otimes \D[r]\,B \ar[r]^{\Gl}
& \D[r]\,B
& \D[r]\,B \otimes \I \ar[l]_{\Gr}
}
\]
\[
\xymatrix@C=10ex{
\D[q]\,B \otimes \D[r+s]\,B  \ar[d]_{\tid \otimes \tduplicate}
& \D[q+r+s]\,B \ar[l]_{\tduplicate} \ar[r]^{\tduplicate}
& \D[q+r]\,B \otimes \D[s]\,B \ar[d]^{\tduplicate \otimes \tid}
\\
\D[q]\,B \otimes (\D[r]\,B \otimes \D[s]\,B) \ar[rr]^{\Ga}
& & (\D[q]\,B \otimes \D[r]\,B) \otimes \D[s]\,B
}
\]
\[
\xymatrix@C=22ex{
\D[(q+r)s]\,B \ar[r]^{\tdisplay} \ar[d]_{\tduplicate}
& \D[q+r]\,(\D[s]\,B) \ar[d]^{\tduplicate}
\\
\D[qs]\,B \otimes \D[rs]\,B \ar[r]^{\tdisplay \otimes \tdisplay}
& \D[q](\D[s]\,B) \otimes \D[r](\D[s]\,B)
}
\]
\[
\xymatrix{
\D[qr]\,B \otimes \D[qs]\,B \ar[d]_{\display \otimes \display}
  & \D[q(r+s)]\,B \ar[l]_{\tduplicate} \ar[r]^{\display}
  & \D[q](\D[r+s]\,B) \ar[d]^{\fmap\tduplicate}
\\
\D[q](\D[r]\,B) \otimes \D[q](\D[s]\,B) \ar[rr]^{\tzip}
&&
\D[q](\D[r]\,B \otimes \D[s]\,B)
}
\]

A $\D$-coalgebra is a functor $A : (\R,\leq) \to \CC$ with family of
morphisms $\expose[r,s] : A_{rs} \to \D[r]\,A_s$ natural in $r$ and
$s$.  For the $\D$-coalgebra $\D[\_]\,B$ the family $\expose$ is just
$\tdisplay$, and the suitably generalizable laws for $\tdisplay$ are
required to hold for $\texpose$:
\[
\xymatrix@C=10ex{
A_r  \ar[d]_{\texpose} \ar@{=}[dr]
\\
\D[1]\,A_r \ar[r]^{\textract}
  & A_r
}
\qquad
\xymatrix@C=12ex{
A_{qrs} \ar[d]_{\texpose} \ar[r]^{\texpose}
  & \D[qr]\,A_s \ar[d]^{\tdisplay}
\\
\D[q]\,A_{rs} \ar[r]^{\tfmap\,\texpose}
  & \D[q]\,(\D[r]\,A_s)
}
\]
Further, $A$ needs to map the additive monoidal structure $(\R,+,0)$
to the monoidal structure $(\CC,\otimes,\I)$ associated with the
tensor product in $\CC$.  We choose to overload the names
$\tduplicate$ and $\tdrop$ here to accommodate for the generalization
from $\R$-comonads to $\R$-comonad algebras:
\[
\begin{array}{lcl}
  \tduplicate & : & \Hom {A_{r+s}} {A_r \otimes A_s} \\
  \tdrop      & : & \Hom {A_0} {\I} \\
\end{array}
\]
The laws of $\tduplicate$ and $\tdrop$ for comonadic objects
$\D[r]\,B$ immediately generalize to comonad algebras $A_r$:
\[
\xymatrix@C=12ex{
A_{0} \otimes A_r \ar[d]_{\tdrop \otimes \tid}
& A_r \ar[l]_{\tduplicate} \ar[r]^{\tduplicate} \ar@{=}[d]
& A_r \otimes A_{0} \ar[d]^{\tid \otimes \tdrop}
\\
\I \otimes A_r \ar[r]^{\Gl}
& A_r
& A_r \otimes \I \ar[l]_{\Gr}
}
\]
\[
\xymatrix@C=10ex{
A_q \otimes A_{r+s}  \ar[d]_{\tid \otimes \tduplicate}
& A_{q+r+s} \ar[l]_{\tduplicate} \ar[r]^{\tduplicate}
& A_{q+r} \otimes A_s \ar[d]^{\tduplicate \otimes \tid}
\\
A_q \otimes (A_r \otimes A_s) \ar[rr]^{\Ga}
& & (A_q \otimes A_r) \otimes A_s
}
\]
\[
\xymatrix@C=22ex{
A_{(q+r)s} \ar[r]^{\texpose} \ar[d]_{\tduplicate}
& \D[q+r]\,A_s \ar[d]^{\tduplicate}
\\
A_{qs} \otimes A_{rs} \ar[r]^{\texpose \otimes \texpose}
& \D[q]A_s \otimes \D[r]A_s
}
\]
\[
\xymatrix{
A_{qr} \otimes A_{qs} \ar[d]_{\expose \otimes \expose}
  & A_{q(r+s)} \ar[l]_{\tduplicate} \ar[r]^{\expose}
  & \D[q]\,A_{r+s} \ar[d]^{\fmap\tduplicate}
\\
\D[q]A_r \otimes \D[q]A_s \ar[rr]^{\tzip}
&&
\D[q](A_r \otimes A_s)
}
\]

Graded comonad algebras are closed under pointwise sums $(\sumt I A)_r = \sumt {i:I} {A_{i,r}}$ and products $(\tupt I A)_r = \tupt {i:I} {A_{i,r}}$.
\[
\begin{array}{lcl}
  \expose[\sumt I A] & : & \Hom {(\sumt I A)_{rs}} {\D[r](\sumt I A)_s} \\
  \expose[\sumt I A] & = & \left[  \fmap{\iota_i} \comp \expose[A_i] \right]_{i:I}
\\[1ex]
  \tdrop[\sumt I A] & : & \Hom {(\sumt I A)_0} \I \\
  \tdrop[\sumt I A] & = & \left[ \tdrop[A_i] \right]_{i:I}
\\[1ex]
  \duplicate[\sumt I A] & : & \Hom {(\sumt I A)_{r+s}} {(\sumt I A)_r \otimes (\sumt I A)_s} \\
  \duplicate[\sumt I A] & = & \left[ (\iota_i \otimes \iota_i) \comp \duplicate[A_i] \right]_{i:I}
\\[2ex]
  \expose[\tupt I A] & : & \Hom {(\tupt I A)_{rs}} {\D[r](\tupt I A)_s} \\
  \expose[\tupt I A] & = & \tzip \comp \tupt {i:I} {\expose[A_i]}
\\[1ex]
  \tdrop[\tupt I A] & : & \Hom {(\tupt I A)_0} \I \\
  \tdrop[\tupt I A] & = & \isot \comp \tupt {i:I} {\tdrop[A_i]}
\\[1ex]
  \duplicate[\tupt I A] & : & \Hom {(\tupt I A)_{r+s}} {(\tupt I A)_r \otimes (\tupt I A)_s} \\
  \duplicate[\tupt I A] & = & \isot \comp \tupt {i:I} {\duplicate[A_i]}
\end{array}
\]
This enables us to interpret all positive types of CBPV as graded
comonad coalgebras.


\subsection{Structured graded comonads and their algebras}

Coeffect, quantitative, and many modal type systems maintain a typing
context where each variable $x$ is annotated by a resource qualifier
$r$ in addition to its type $\tau$.  Such a typing context
$(r_1x_1{:}\tau_1, \dots, r_nx_n{:}\tau_n) =: \gamma\Gamma$ can be
split into a pure typing context
$\Gamma = x_1{:}\tau_1, \dots, x_n{:}\tau_n$ and a resource context
$\gamma = x_1{:}r_1, \dots, x_n{:}r_n$ such that
$\dom \gamma = \dom \Gamma$.  We shall freely mix the two notations as
it suits our purpose.

In coeffect-graded CBPV, we wish to interpret each type in the context
as a $\D$-coalgebra for a fixed graded comonad $\D$.  The
interpretation $\den \Gamma$ of the context $\Gamma$ should then be a
comonad coalgebra over the grading $\gamma$ such that judgements
$\qCompTy \gamma \Gamma t N$ can be interpreted as morphisms
$\dent t : \Hom {\Den\Gamma \gamma} {\denn N}$.  Since each variable
comes with its own resource qualifier, we cannot simply model the
context as a tensor product $\tupt {z:\dom\Gamma} \den{\Gamma(z)}$ of
$\D$-coalgebras since this product would indexed by a single resource
qualifier $r \in \R$ rather than a resource context
$\gamma : \dom\Gamma \to \R$.  The solution offered by
\citet{orchard:icfp14} are \emph{structured indexed comonads}.  We
shall generalize this to comonad coalgebras to the extend needed for
interpreting contexts.

\citet{mcBride:wadler60} observed that resource contexts
$\gamma : \R^I$ form a left $\R$-semimodule under pointwise addition
$(\gamma + \delta)(i) = \gamma(i) + \delta(i)$ and scaling
$(r \cdot \gamma)(i) = r \cdot \gamma(i)$.  Contexts $\Gamma$ can thus
be interpreted as \emph{$R^{\dom \Gamma}$-graded}
(or \emph{structured}) $\D$-coalgebras $C$ with
the following operations:
\[
\begin{array}{lcl}
  \tdrop[C]     & : & \Hom {C_0} {\I} \\
  \duplicate[C] & : & \Hom {C_{\gamma+\delta}} {C_\gamma \otimes C_\delta} \\
  \duplicate[C] & : & \Hom {C_{\sumt I \gamma}} {\tupt {i:I} C_{\gamma_i}} \\
  \expose[C]    & : & \Hom {C_{r\gamma}} {\D[r]\,C_\gamma} \\
\end{array}
\]
The second, generalized form of $\tduplicate$ will be used to split
resources accumulated from $I$ parties.  Note that
$A_r := C_{r\gamma}$ flattens a structured $\D$-coalgebra $C$ into an
ordinary one ($A$).

We will also need to interpret context extension.  To this end, we
shall employ a structured product
$(C \boxtimes D)_{\gamma.\delta} = C_\gamma \otimes D_\delta$ where
$\gamma : \R^I$ and $\delta : \R^J$ and thus $C \boxtimes D$ is a
$\R^{I+J}$-graded $\D$-coalgebra.  Further, we implicitely use the
isomorphism between $1$-structured $\D$-coalgebras $C : \R^1 \to \CC$
and $\R$-graded $\D$-coalgebras $A : \R \to \CC$ and define
\[
\den{\ext \Gamma x P}
  = \den \Gamma \boxtimes \denp P
  ,
\]
sweeping name issues under the carpet (to be handled by de Bruijn indices).


\begin{figure}[htbp]
\flushleft
\ruler{}
Types.
\[
\begin{array}{lllrl@{\qquad}l}
\PTy & \ni & P
  & ::= & \Box N
     \mid o \mid \sumty i I P \mid \tupty i I P
  & \nbox{Value types (positive types)} \\
\NTy & \ni & N
  & ::= & %\diamond P %
          \graybox{\compty r P}
     \mid \gqfun r P N \mid \recty i I N
  & \nbox{Computation types (negative types)} \\
\Cxt & \ni & \Gamma
  & ::= & \cempty \mid \ext \Gamma x P \mid \graybox{\ext \Gamma y N}
  & \nbox{Typing context}
\\
\R & \ni & \graybox{r,s}
   & ::= & 0 \mid 1 \mid r + s \mid rs
   & \mbox{Resource qualifiers}
\\
\RCxt & \ni & \graybox{\gamma,\delta}
  & ::= & \cempty \mid \ext \gamma x r \mid \ext \gamma y r
  & \mbox{Resource context}
\end{array}
\]
\dashruler{}
Terms.
\[
\begin{array}{lllrl@{\qquad}l}
\PTm & \ni & v,w
  & ::= & x
     \mid \thunk t
     \mid \inj i v
     \mid \ptup{\bar v}
  & \nbox{Values (positive terms)} \\
\NTm & \ni & t,u
  & ::= & \graybox{y} \mid \graybox{\qlet r y u t}
     \mid \qlet {\graybox r} x v t
  & \nbox{Computations (negative terms):}
\\ &&& \mid &
         \graybox{\qforced r v y t}
    \mid \qcase {\graybox r} v {\overline{x.\,t}}
    \mid \qsplits {\graybox r} v {\bar x} t
  & \nbox{value eliminations}
\\ &&& \mid &
         \ret v
    \mid \bind x u t
    % \mid \qbind {\graybox r} x u t
  & \nbox{monad operations}
\\ &&& \mid &
         \lam x t      \mid \app t v
  & \nbox{functions}
\\ &&& \mid &
         \trecord\{\overline{i:t}\} % \ntup{\bar t}
       \mid \proj i t
  & \nbox{lazy tuples (records)}
\end{array}
\]
\dashruler{}
Value typing \fbox{$\gqValTy \gamma \Gamma v P$}\,.
\begin{gather*}
 \nru{\rvar^+}{}
     {\ValTy {\gqext 0\Gamma 1x P} x P}
\qquad
 \nru{\rintro\Box}
     {\qCompTy \gamma \Gamma t N
    }{\qValTy \gamma \Gamma {\thunk t} {\Box N}}
\\[1.5ex]
 \nru{\rintro\GS}
     {\qValTy \gamma \Gamma v {P_i}
    }{\qValTy \gamma \Gamma {\inj i v} {\sumt I P}}
\qquad
 \nru{\rintro\otimes}
     {\forall i{:}I, \ \gqValTy {\gamma_i} \Gamma {v_i} {P_i}
    }{\gpValTy {\GS_{i:I}\gamma_i} \Gamma {\ptup v} {\tupt I P}}
\end{gather*}
\dashruler{}
Computation typing \fbox{$\gqCompTy \gamma \Gamma t N$}\,.
\vspace{-2ex}
\begin{gather*}
\graybox{
 \nru{\rvar^-}{}
     {\ValTy {\gqext 0 \Gamma 1 y N} y N}
}
\qquad
\graybox{
 \nru{\rlet^-}
     {\qCompTy \delta \Gamma u N \qquad
      \CompTy {\qext \gamma \Gamma r y N} t {N'}
    }{\gpCompTy {\gamma + r\delta} \Gamma {\qlet r y u t} {N'}}
}
\\[1.5ex]
 \nru{\rlet^+}
     {\gqValTy \delta \Gamma v P \qquad
      \CompTy {\gqext \gamma \Gamma r x P} t N
    }{\gpCompTy {\gamma + r\delta} \Gamma {\gqlet r x v t} N}
\qquad
 \nru{\relim\Box}
     {\gqValTy \delta \Gamma v {\Box N} \qquad
      \CompTy {\gqext \gamma \Gamma r y N} t {N'}
    }{\gpCompTy {\gamma + r\delta} \Gamma {\gqforced r v y t} {N'}}
\\[1.5ex]
 \nru{\relim\GS}
     {\gqValTy \delta \Gamma v {\sumt I P} \qquad
      \forall i{:}I,\ \CompTy {\gqext \gamma \Gamma r {x_i} {P_i}} {t_i} N
    }{\gpCompTy {\gamma + r\delta} \Gamma {\caser v {\{\graybox{r} x_i.\, t_i\}_{i:I}}} N}
\qquad
 \nru{\relim\otimes}
     {\gqValTy \delta \Gamma v {\tupt I P} \qquad
      \gqCompTy \delta {\extr \Gamma {\overline{\graybox{r}x_i{:}P_i}^{i:I}}} t N
    }{\gpCompTy {\gamma + r\delta} \Gamma {\gqsplits r v {\bar x} t} N}
\\[1.5ex]
 \nru{\rintro\diamond}
     {\qValTy \gamma \Gamma v P
    }{\qCompTy {\graybox r\gamma} \Gamma {\ret v} {\compty {\graybox r} P}}
\qquad
 \nru{\relim\diamond}
     {\gqCompTy \delta \Gamma u {\compty {\graybox r} P} \qquad
      \CompTy {\gqext \gamma \Gamma r x P} t  N
    }{\gpCompTy {\gamma + \delta} \Gamma {\bind x u t} N}
%  \nru{\rintro\diamond}
%      {\qValTy \gamma \Gamma v P
%     }{\qCompTy \gamma \Gamma {\ret v} {\diamond P}}
% \qquad
%  \nru{\relim\diamond}
%      {\gqCompTy \gamma \Gamma u {\diamond P} \qquad
%       \CompTy {\gqext \delta \Gamma r x P} t  N
%     }{\gpCompTy {r\gamma + \delta} \Gamma {\gqbind r x u t} N}
\\[1.5ex]
 \nru{\rintro\lolli}
     {\CompTy {\gqext \gamma \Gamma r x P} t N
    }{\gqCompTy \gamma \Gamma {\lam x t} {\gqfun r P N}}
\qquad
 \nru{\relim\lolli}
     {\gqCompTy \gamma \Gamma t {\gqfun r P N} \qquad
      \gqValTy \delta \Gamma v P
    }{\gpCompTy {\gamma + r\delta} \Gamma {\app t v} N}
\\[1.5ex]
 \nru{\rintro\Pi}
     {\forall i{:}I,\ \qCompTy \gamma \Gamma {t_i} {N_i}
    }{\qCompTy \gamma \Gamma {\trecord {\{i : t_i\}_{i:I}}} {\rect I N}}
    % }{\qCompTy \gamma \Gamma {\ntup{\overline{t_i}^{i:I}}} {\rect I N}}
\qquad
 \nru{\relim\Pi}
     {\qCompTy \gamma \Gamma t {\rect I N}
    }{\qCompTy \gamma \Gamma {\proj i t}  {N_i}}
%\\[1.5ex]
\qquad
\graybox{
 \nrux{\rweak}
      {\gqCompTy {\gamma'} \Gamma t N}
      {\gqCompTy \gamma \Gamma t N}
      {\gamma \leq \gamma'}
}
\end{gather*}
\rule{\textwidth}{0.2pt}
  \caption{Coeffect-graded call-by-push-value.}
  \label{fig:coeff-cbpv}
\end{figure}


\subsection{Coeffect-graded CBPV: syntax and typing}

We now have the mathematical structures in place to define a
coeffect-graded variant of CBPV (see Fig.~\ref{fig:coeff-cbpv}).
The difference to pure CBPV is laid out in \emph{gray boxes}.

The fundamental novelty is that the typing judgements
$\qValTy \gamma \Gamma v P$ and $\qCompTy \gamma \Gamma t N$ are
equipped with resource contexts $\gamma$ matching the typing contexts
$\Gamma$.  A common pattern in the rules is that resource requirements
of the subterms are added when both subterms are or maybe evaluated at
runtime (rules \rintro\otimes, $\rlet^{+/-}$,
\relim{\Box/\GS/\otimes/\diamond/\lolli}).  Note that in \relim\GS,
the branches $t_i$ of the case statement (\relim\GS) share a resource
context $\gamma$, since only one of the branches is executed at
runtime.  Via rule $\rweak$,
the different resource requirements of the branches can be
subsumed under their maximum wrt.\ $\leq_\R$.  Similarly, the
components $t_i$ of a record (\rintro\Pi) share a resource context
since projection only retrieves one of the components (\relim\Pi).  This is
the opposite of eager tuples (\rintro\otimes) where the elimination
makes all components available at the same time (\relim\otimes), thus,
all components have to be evaluated at runtime.

Function types $\qfun r P N$ are now graded by a resource qualifier
$r$ that specifies how the function argument is to be used in the
function body.  (This type is often written $!_{r}P \lolli N$.)  In
quantitative typing with $\R = \Pot \bN$, qualifier $r$ gives the
possible usage quantities of the function argument, e.g. $\{1\}$ for
exactly one use (linear), $\{0,1\}$ for at most one use (affine),
$\{0\}$ for no use (constant), and $\bN$ for arbitrary use
(unrestricted).  A resource qualifier could also be a security level
(public or private), or a sensitivity level (a non-negative real)
\citep{reedPeirce:icfp10}.  If a lambda abstraction $\lam x t$ is
typed with $\qfun r P N$, qualifier $r$ is attached to variable $x$ in
the resource context (rule \rintro\lolli).  If a function
$t : \qfun r P N$ is applied (rule \relim\lolli), we need an
$r$-qualified argument $v : rP$.  We could have given a qualified
value typing judgement $\qValTy \gamma \Gamma v {rP}$ in the style of
\citet{mcBride:wadler60} that---in the quantitative
interpretation---provides $r$ copies of $v$ to be consumed by the
function.  Such a judgement could come with a scaling rule
\[
\ru{\qValTy \gamma \Gamma v {sP}
  }{\qValTy{r\gamma}\Gamma v {(rs)P}}
\]
that allows to scale the production of $v$ by $r$ if the resources are
scaled accordingly (from $\gamma$ to $r\gamma$).  We bake scaling instead
into the transition from values to computations.
Thus, $\relim\lolli$ receives an
argument $\qValTy \delta \Gamma v P$, and to satisfy the demands of
the function $\qCompTy \gamma \Gamma t {\qfun r P N}$, the resources
$\delta$ for the argument are scaled by $r$, summing the resource
requirements for the application to $\gamma + r\delta$.
%
Analogous scaling of the eliminatee is baked into the other value
eliminators (\relim\Box, \relim\GS, \relim\otimes), into the
\rlet-rules, and into \rintro\diamond.

The monadic type $\compty r P$ records the multiplicity $r$ of the
value of type $P$ resulting from the computation.  This construction
is dual to the comonadic type $\thunkty e N$ from effect-graded CBPV
(Section~\ref{sec:effect-cbpv}).  Since negative types are not
$\D$-coalgebras and do not support scaling, the scaling in
$\rintro\diamond$ is the last opportunity for scaling before entering
the monad.  Typing of bind ($\bind x u t$) attaches the resource qualifier $r$ store in $\compty r P$ to the variable $x$ (\relim\diamond).



As a consequence of eliminatee scaling, $\relim\Box$ is no longer
``natural-deduction'' style like projection, but ``sequent-calculus''
style like $\relim\diamond$.  The original construct $\force v$ could
eliminate an unscaled thunk $\qValTy \gamma \Gamma v {\Box N}$,
however, computation typing $\qCompTy \gamma \Gamma {\force v} N$ has
no scaling option, since negative types $N$ will not be interpreted as
$\D$-coalgebras.  Scaling is semantically restricted to positive
types, and in our type system, to context entries.  Thus, we extend
CBPV to negative variables $y : N$ that come with a resource qualifier
$r$ in the context and can there be interpreted as elements of
$\D[r]\,\denn N$.  This is a modification also taken in call-by-need
CBPV \citep{mcDermottMycroft:esop19}; this compromise allows us to
keep CBPV's polarization of types where positive types stand for
comonad coalgebras and negative types for monad algebras.


\subsection{Coeffect-graded CBPV: denotational semantics}


%\subsubsection{Interpretation of types}

Positive types $P$ are interpreted as $\D$-algebras
$\denp P : (\R,\leq) \to \CC$ and negative types $N$ as objects
$\denn N : \CC$, except for in contexts, where they are interpreted as
$\D$-algebras $\Den N r = \D[r]\,\denn N$.  With $\den P = \denp P$,
the interpretation of contexts is thus
$\den \Gamma = \boxtimes_{x:\dom\Gamma} \den{\Gamma(x)}$.
\[
\begin{array}{lcl}
  \Denp\_\_ & : & \PTy \to [(\R,\leq) \to \CC] \\
  \Denp{\Box N}    r & = & \D[r]\, \denn N \\
  \Denp{\sumt I P} r & = & \coprod_{i:I} \Denp{P_i} r \\
  \Denp{\tupt I P} r & = & \otimes_{i:I} \Denp{P_i} r \\
\end{array}
\qquad\qquad
\begin{array}{lcl}
  \denn\_\_ & : & \NTy \to \CC \\
  \denn{\compty r P} & = & \T \Denp P r \\
  \denn{\qfun r P N} & = & \Denp P r \lolli \denn N \\
  \denn{\rect I N}   & = & \prod_{i:I} \denn{N_i} \\
\end{array}
\]
The symmetric monoidal category $\CC$ needs to come with cartesian
products $\rect I B$ as well as with distributive coproducts
$\coprod_I A$ with
$\tdist : \Hom {C \otimes \coprod_I A} {\coprod_{i:I} {(C \otimes A_i)}}$.

Computations $\qCompTy \gamma \Gamma t N$ are interpreted as morphisms
$\dent t : \Hom {\Den\Gamma\gamma} {\denn N}$ and values
$\qValTy \gamma \Gamma v P$ as families
$\denv v r : \Hom {\Den\Gamma{r\gamma}} {\Denp P r}$ natural in $r$.
Naturality here means that
$\Denp P {r \leq s} \comp \denv v r = \denv v s \comp \left(\Den \Gamma {(\_
    \cdot \gamma)}\right)_{r \leq s}$.
Again, because of $\rweak$, we interpret typing derivations rather than terms.
The interpretation is now rather straightforward, but we spell it out for reference.
\[
\begin{array}{llcl}
\rvar^+
  & \denv {\ValTy{\qext 0 \Gamma 1 x P} x P} r
  & = & \Gr \comp (\tdrop[\den\Gamma] \otimes \tid[\Denp P r])
\\
\rintro\Box
  & \denv {\qValTy \gamma \Gamma {\thunk t} {\Box N}} r
  & = & \fmapt[{\D[r]}]{\dent t} \comp \expose{\den \Gamma}
\\
\rintro\GS
  & \denv{\qValTy \gamma \Gamma {\inj i v} {\sumt I P}} r
  & = & \iota_i \comp \denv v r
\\
\rintro\otimes
  & \denv{\pValTy {\sumt I \gamma} \Gamma {\tup v} {\tupt I P}} r
  & = & \tupt {i:I} \denv {v_i}r \comp \duplicate
\\
\end{array}
\]
\[
\begin{array}{llcl}
\rvar^-
  & \dent {\oCompTy{\qext 0 \Gamma 1 y N} y N}
  & = & \Gr \comp (\tdrop[\den\Gamma] \otimes \extract[\denn N])
\\
\rlet^{-}
  & \dent {\pCompTy {\gamma + r\delta} \Gamma {\qlet r y u t} {N'}}
  & = & \dent t
  \comp (\tid[\Den \Gamma \gamma] \otimes
           (\fmapt[{\D[r]}] \dent u \comp \expose[\den \Gamma]))
\\ &&& {~}
  \comp \duplicate
\\
\rlet^{+}
  & \dent {\pCompTy {\gamma + r\delta} \Gamma {\qlet r x v t} {N}}
  & = & \dent t
  \comp (\tid[\Den \Gamma \gamma] \otimes
           (\expose[\denp P] \comp \denv v r))
  \comp \duplicate
\\
\relim\Box
  & \dent {\pCompTy {\gamma + r\delta} \Gamma {\qforced r v y t} {N'}}
  & = & \dent t
  \comp (\tid[\Den \Gamma \gamma] \otimes \denv v r)
  \comp \duplicate
\\
\relim\GS
  & \dent {\pCompTy {\gamma + r\delta} \Gamma {\caser v \{r x_i.\, t_i\}_{i:I}} {N}}
  & = & [\dent {t_i}]_{i:I} \comp \tdist
  \comp (\tid[\Den \Gamma \gamma] \otimes \denv v r)
  \comp \duplicate
\\
\relim\otimes
  & \dent {\pCompTy {\gamma + r\delta} \Gamma {\qsplits r v {\bar x} t} {N}}
  & = & \dent t \comp \isot
  \comp (\tid[\Den \Gamma \gamma] \otimes \denv v r)
  \comp \duplicate
\\
\rintro\diamond
  & \dent {\pCompTy {r\gamma} \Gamma {\ret v} {\compty r P}}
  & = & \treturn \comp \denv v r
\\
\relim\diamond
  & \dent {\pCompTy {\gamma + r\delta} \Gamma {\qbind r x u t} {N}}
  & = & \run[\den N] \comp \fmapt[\T]{\dent t} \comp \strengthl
\\ &&& {~}
  \comp (\tid[\Den \Gamma \gamma] \otimes \dent u)
  \comp \duplicate
\\
\rintro\lolli
  & \dent {\qCompTy \gamma \Gamma {\lam x t} {\qfun r P N}}
  & = & \Lambda \dent t
\\
\relim\lolli
  & \dent{\pCompTy {\gamma + r\delta} \Gamma {\app t v} N}
  & = & \teval \comp (\dent t \otimes \denv v r) \comp \duplicate
\\
\rintro\Pi
  & \dent {\qCompTy \gamma \Gamma {\recrd I t} {\rect I N}}
  & = & \langle \dent {t_i} \rangle_{i:I}
\\
\relim\Pi
  & \dent {\qCompTy \gamma \Gamma {\proj i t} {N_i}}
  & = & \pi_i \comp \dent t
\\
\rweak
  & \dent {\qCompTy \gamma \Gamma t N}
  & = & \dent t \comp \Den \Gamma {\gamma \leq \gamma'}
\\
\end{array}
\]



%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.

  This material is based upon work supported by the
  Swedish Research Council (Vetenskapsrådet)
  under Grant
  No.~2019-04216 \emph{Modal Dependent Type Theory}.

  % This material is based upon work supported by the
  % \grantsponsor{GS100000001}{National Science
  %   Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  % No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  % No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  % conclusions or recommendations expressed in this material are those
  % of the author and do not necessarily reflect the views of the
  % National Science Foundation.
\end{acks}


%% Bibliography
\bibliography{medium}


% %% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
